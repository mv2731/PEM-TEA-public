# -*- coding: utf-8 -*-
"""Modes 1-3_H2 TEA_31Mar2022.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oNyGLHzLJaGtctVNP4aJsJeDfMTk3k_D

# 1.) Load data into dataframe and produce mean-varied distributions ("modified LMPs")
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook 
import matplotlib.pyplot as plt
import pandas as pd
dynamic = pd.read_csv('Martinez_2020.csv') # use appropriate .csv
dynamic

#make new df of one price - Feb 8, 2022
# constant  LCOE in the range of 2-7 c/kWh (or  minus 2 to 9 c/kWh) 
# price = 0.02
#len(dfElPrice)

dfElPrice = dynamic.iloc[:,1]
dfElPrice
Life_1year = len(dfElPrice)
Life_1year

dfElPrice.describe()

# allows user to input a desired mean
# transforms all values in the data frame to correspond to this new mean

def varyMean(desired_mean, df):
    original_mean = df.mean()
    delta = desired_mean - original_mean
    data_list = []
    for i in range(len(df)):
        data = df[i]
        new_data = data + delta
        data_list.append(new_data)
    new_df = pd.DataFrame(data_list)[0]
    return new_df

# desired means: 0.00 to 0.07 $/kWh
# create numpy arrays with mean-transformed datasets 

import numpy as np
mean_array = np.linspace(0,0.07,num=8)
mean_array
df_array = []
for mean in mean_array:
    df_array.append(varyMean(mean, dfElPrice))

df_array_dict = {}
for i in range(len(mean_array)):
    df_array_dict[str(mean_array[i])]=df_array[i]
df_array_dict.keys()

# test the length of a sample array and display values
Life_1year = len(df_array_dict['0.0'])
df_array_dict['0.04']

#determine the % of negative prices in each mean varied price distribution - Feb 8, 2022

for key in df_array_dict.keys():
#     print(df_array_dict[key])
    dfElPrice = df_array_dict[key]
    count = 0
    for price in dfElPrice:
        if price < 0:
            count+=1
    print(key,round(count/len(dfElPrice)*100,2),"%")

"""# 2.) Create 10 years worth of electricity prices for each distribution"""

# use dfElPrice (original dataset, not modified LMPs) for sensitivity analysis
# create 10 years of locational marginal prices (LMPs) by appending the dataset 
# to itself

df2 = dfElPrice
for i in range(9):
    test = dfElPrice.append(df2)
    dfElPrice = test
test
dynamic = test 
dynamic
Life_hours = len(dynamic)

# #make all prices one prices - Feb 8, 2022
# #-2 to 7 c/kWh
# # 2-7 c/kWh (or  minus 2 to 9 c/kWh) 
# dfElPrice_const_dict = {}

# dfElPrice_const = dfElPrice.copy()
# for price in (-0.02,-0.01,0.00,0.01,0.02,0.03,0.04,0.05,0.06,0.07):
#     for i in range(Life_hours):
#         dfElPrice_const.iloc[i] = price
#     dfElPrice_const_dict[str(price)] = dfElPrice_const
    
# dfElPrice_const_dict

#make all prices one prices - Feb 8, 2022
#-2 to 7 c/kWh
# 2-7 c/kWh (or  minus 2 to 9 c/kWh) 
dfElPrice_const_dict = {}

dfElPrice_const = dfElPrice.copy()
for price in (-0.02,-0.01,0.00,0.01,0.02,0.03,0.04,0.05,0.06,0.07):
    dfElPrice_const_dict[str(price)] = pd.Series(price,index=range(Life_hours))
    
dfElPrice_const_dict

# use modified LMPs to run mode comparisons
# create 10 years of locational marginal prices (LMPs) by appending the dataset 
# to itself

for mean in df_array_dict:
    df2 = df_array_dict[mean]
    for i in range(9):
        test = df_array_dict[mean].append(df2)
        df_array_dict[mean] = test
    test
    dynamic = test 
    dynamic
    Life_hours = len(dynamic)

"""# 3.) Mode 1A - Constant 1.7 Jop"""

#iv curve
Y = lambda X: ((0.156726387554 * X) + 1.47670128643691)
#creates range of Jops
i_plot = [0]
temp_y = 0
for i in range(60):
    temp_y += 0.10
    i_plot.append(round(temp_y,2))

#i_plot
Degradation_Amount = 1

v_plot = [Y(x) for x in i_plot]
# plt.plot(i_plot,v_plot)
v_plot = [x + Degradation_Amount for x in v_plot]
# plt.plot(i_plot,v_plot)

# Commented out IPython magic to ensure Python compatibility.
#plot three curve - actual
# %matplotlib notebook

# Commented out IPython magic to ensure Python compatibility.
# Fitting to exponential curve - baseline efficiency
# %matplotlib notebook 
import matplotlib.pyplot as plt
import numpy as np

import scipy
from scipy import optimize
curve_fit = optimize.curve_fit
import pandas as pd
df = pd.read_csv('fit_data.csv')
df_n =df.dropna()
import math
def fit_func(x, A, C, k):
    return [C + A * (1 - math.exp(-k * value)) for value in x]
    
df_n.index = range(len(df_n))
df = df_n
curve_fit = optimize.curve_fit
data = df_n.values
y_baseline = data[:,1]
x_baseline = data[:,0]
popt, _ = curve_fit(fit_func, x_baseline, y_baseline)
print(popt)
y_fit_baseline = fit_func(x_baseline, 2.71725674, 1.44926681, 0.06970714)

#these three correspond to the order of what is printed (popt)

                    #then use them below as
                    #Fit_2, Fit_1, Fit_3
        
import matplotlib.pyplot as plt
plt.plot(x_baseline, y_baseline,"ro")
# plt.plot(x_baseline, y_fit_baseline)
plt.xlabel('Current density')
plt.ylabel('Voltage')
plt.legend(['data', 'fit'])
# plt.show()

#overwriting x for actual output

x = np.linspace(0, 6, num=61)
x = np.round(x, 1) #rounding needs to be 1

import math
Jop_ = 1.7
Fit_1 = 1.44926681  #C
Fit_2 = 2.71725684 #A
Fit_3 = 0.06970714 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
# plt.plot(x)

y_fit_baseline = Y_vector(x)
print("Vop at Jop 1.7 for baseline efficiency:", Y(1.7))

plt.plot(x,y_fit_baseline)
plt.show()

plt.show()

# Commented out IPython magic to ensure Python compatibility.
# Fitting to exponential curve - low efficiency curve
import matplotlib.pyplot as plt
# %matplotlib notebook

import scipy
from scipy import optimize
curve_fit = optimize.curve_fit
import pandas as pd
df = pd.read_csv('iv_fit_low.csv')
df_n =df.dropna()
import math
def fit_func(x, A, C, k):
    return [C + A * (1 - math.exp(-k * value)) for value in x]
    
df_n.index = range(len(df_n))
df = df_n
curve_fit = optimize.curve_fit
data = df_n.values
y_low = data[:,1]
x_low = data[:,0]
popt, _ = curve_fit(fit_func, x_low, y_low)
print(popt)
y_fit_low = fit_func(x_low, 3.69385268, 1.4935848, 0.0630398)
#  Fit_2, Fit_1, Fit_3

import matplotlib.pyplot as plt
plt.plot(x_low, y_low,"ro")
# plt.plot(x_low, y_fit_low)
plt.xlabel('Current density')
plt.ylabel('Voltage')
plt.legend(['data', 'fit'])
# plt.show()

#overwriting x for actual output

x = np.linspace(0, 6, num=61)
x = np.round(x, 1) #rounding needs to be 1

import math
Jop_ = 1.7
Fit_1 = 1.4935848  #C
Fit_2 = 3.69385268 #A
Fit_3 = 0.0630398 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
# plt.plot(x)

y_fit_low = Y_vector(x)
print("Vop at Jop 1.7 for low efficiency:",Y(1.7))

plt.plot(x,y_fit_low)
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# Fitting to exponential curve - high efficiency curve
# %matplotlib notebook 
import scipy
from scipy import optimize
curve_fit = optimize.curve_fit
import pandas as pd
df = pd.read_csv('iv_fit_high.csv')
df_n =df.dropna()
import math
def fit_func(x, A, C, k):
    return [C + A * (1 - math.exp(-k * value)) for value in x]
    
df_n.index = range(len(df_n))
df = df_n
curve_fit = optimize.curve_fit
data = df_n.values
y_high = data[:,1]
x_high = data[:,0]
popt, _ = curve_fit(fit_func, x_high, y_high)
print(popt)
y_fit_high = fit_func(x_high, 0.46679002, 1.46767985, 0.41852023)

#these three correspond to the order of what is printed (popt)

                    #then use them below as
                    #Fit_2, Fit_1, Fit_3
        
import matplotlib.pyplot as plt
plt.plot(x_high, y_high,"ro")
# plt.plot(x_high, y_fit_high)
plt.xlabel('Current density')
plt.ylabel('Voltage')
plt.legend(['data', 'fit'])
# plt.show()

x = np.linspace(0, 6, num=61)
x = np.round(x, 1) #rounding needs to be 1

import math
Jop_ = 1.7
Fit_1 = 1.46767985  #C
Fit_2 = 0.46679002 #A
Fit_3 = 0.41852023 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
# plt.plot(x)

y_fit_high = Y_vector(x)
print("Vop at Jop 1.7 for high efficiency:", Y(1.7))

plt.plot(x,y_fit_high)
plt.show()

# Commented out IPython magic to ensure Python compatibility.
#plot three curve - fit and data - MUST RUN THREE EFFICIENCIES FIRST!!
# %matplotlib notebook 
plt.plot(x, y_fit_baseline)
plt.plot(x, y_fit_low)
plt.plot(x, y_fit_high)

plt.plot(x_baseline, y_baseline,"r^")
plt.plot(x_low, y_low,"ro")
plt.plot(x_high, y_high,"bo")
plt.legend(["Baseline","Low","High"])

plt.show()

# Commented out IPython magic to ensure Python compatibility.
#plot three curve - data - MUST RUN THREE EFFICIENCIES FIRST!!
# %matplotlib notebook 
plt.plot(x_baseline, y_baseline,"r^")
plt.plot(x_low, y_low,"ro")
plt.plot(x_high, y_high,"bo")
plt.legend(["Baseline","Low","High"])

plt.show()

Jop_ = 1.7
  Fit_1 = 1.44926681  #C
  Fit_2 = 2.71725674 #A
  Fit_3 = 0.06970714 #K
  Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
  #Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
  #C + A * (1 - math.exp(-k * value)) for value in x


  #for iV curve plot
  iv_plotting = []
  
  i_plot = [0]
  temp_y = 0
  for i in range(60):
      temp_y += 0.10
      i_plot.append(round(temp_y,2))
  v_plot = [Y(x) for x in i_plot]
  iv_plotting.append([i_plot,v_plot])

#2.8.22 - iV curve
Fit_1 = 1.44926681  #C
Fit_2 = 2.71725674 #A
Fit_3 = 0.06970714 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
x = (6,5.4,3.7,3.0,2.9,2.4,2.3)
1.48/Y_vector(x)

##HIGH  EFFICIENCY - FEB 10, 2022

#USE THIS VERSION - MODE 1A - HANDLING TERMINAL VOLTAGE 
# ##############################################
## USE THIS VERSION FOR 1A!! FEBRUARY 7, 2022
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# 

import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode1a.csv","w")
print("Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []

# runs Mode 1A for all datasets 
# # for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
# for mean in df_array_dict:
# #for mean in ["0.0"]:     
#     print("Mean Price:", mean)
# #     dfElPrice = df_array_dict[mean]

    # Technical Variables 
Jop_rated = 1.7 # A/cm2
Vop_rated = 1.7053156722491154 # Volts; #THIS CHANGES BASED ON THE IV CURVE
Capacity = 1000  # conversion factor from kW to watts
Capacity_kW = 10000 #kW
Stack_cost_1kW = 473.92 #2020 USD 
M_BOP_1kW = 150.10 #2020 USD 
E_BOP_1kW = 130.48 #2020 USD 
CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

# changing capex with current density
Electronics_percentage = 0.26 # cost increase
# for electrical balance of plant and phase separator and dryers
CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

#set_trace()

#     Jop_ = 0.1
Fit_1 = 1.46767985  #C
Fit_2 = 0.46679002 #A
Fit_3 = 0.41852023 #K

Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
#Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
#C + A * (1 - math.exp(-k * value)) for value in x

Jop = [1.7] #ONLY 1.7
# Jop as array
Jop = np.array(Jop)

# Corresponding voltages for Jops

Vop = [Y(Jop[0])] #only 1.7
# Vop as array
Vop = np.array(Vop)

# Vop_copy is a copy of Vop upon which degradation is
# applied.  So we have access to origin Vop if needed
Vop_copy = Vop.copy()

#set_trace()

#for iV curve plot
iv_plotting_1a = []
i_plot = np.linspace(0, 6, num=61)
i_plot = np.round(i_plot, 1) #rounding needs to be 1
v_plot = Y_vector(i_plot)
iv_plotting_1a.append(v_plot)

#set_trace()

#     i_plot = [0]
#     temp_y = 0
#     for i in range(60):
#         temp_y += 0.10
#         i_plot.append(round(temp_y,2))
#     v_plot = [Y(x) for x in i_plot]
#     iv_plotting.append([i_plot,v_plot])

#while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
#     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
#     Vop_ = Y(Jop_) 

n_mol = 2  # constant for H2
F = 96485  # Faraday's constant
V_threshold = 2.9  # voltage at which current removed from options

N_life = 10  # life of electrolyzer

DR = 0.10  # discount rate

# vary A/cm2 in 0.1 increments 0 to 6.0 
#     Jop = [Jop_] 
#     print("Jop:",Jop[0])

#     Vop = [Vop_] #1.79
#     print("Vop:",Vop[0])

#     PReq = []  # kW required per hour
#     for i in range(len(Jop)):  
#         if Jop[i] != 0:
#             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
#         else:
#             PReq.append(0)

# degrade voltage
Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
# every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

# prevents Jop[i] and Vop[i] from being modified
#     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

#         if Jop[i] != 0:
#             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
#         else:
#             PReq[i] = 0
#         return PReq[i]

#12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
M_CAPEX = []  # varying the CAPEX_Electronics with Jop
for k in range(len(Jop)):
    if Jop[k] > 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop[k]*Vop[k]/1000
        Installation_Factor = 1.19 #Installed CAPEX 
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    elif Jop[k] > 0 and Jop[k] <= 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
        Installation_Factor = 1.19
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    else:
        M_CAPEX.append(0)  

# array
M_CAPEX = np.array(M_CAPEX)

M_OM = [x*0.05 for x in M_CAPEX] 

#array
M_OM = np.array(M_OM)

# Rate of fuel production in kg every hour of year 1
M_kgh2 = []
for k in range(len(Jop)):
    if Jop[k] != 0:
        M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
    else:
        M_kgh2.append(0)  # 0 kg produced when Jop=0

# array
M_kg2 = np.array(M_kgh2)

#12.28.21 - LCOH column names list
LCOH_column_names = []
LCOH_2D_data = [] #box

for i in range(len(Jop)):
    LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
    LCOH_column_names.append(name)

break_point = None #to determine hour at which electrolyzer dies
hour = 0
for price in dfElPrice:
#     for price in dfElPrice:  
    # Preq is a numpy array
    hour+=1     
    #Make EC NAN if terminal voltage is reached - Feb 7, 2022
    # if Vop is > Vthreshold make EC NAN
    if Vop_copy >= V_threshold:
        if break_point == None:
            break_point = hour 
        #determine when EOL reached with hour variable
        EC = [np.nan for i in Jop] #must be an array
        EC = np.array(EC)
    else:
        EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage #EC is an array
        
#     set_trace()

    # if EC is NAN then make the corresponding elements NAN - for terminal voltage
    # in M_kg2, M_CAPEX and M_OM

    M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
#     M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
    M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

    #set_trace()

    # array - create marginal LCOH for each Jop; if kg = 0 make nan; maringal LCOH will be NAN if EC is NaN 
    marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

    #set_trace()

    #marginal LCOH per Jop
    # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
    #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
    #LCOH_hourly_data.append(marginal_LCOH_value)

#                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
#         for df_LCOH in df_LCOH_total_list:  

    #minimum LCOH per hour - ignore nan values
    margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
    margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
    #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

    #set_trace()

    #Energy charge minimum
    EC_min = EC[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

    #Jop that minimizes marginal LCOH  and corresponding Vop
    Jop_min = Jop[margLCOH_min_index]
    Vop_copy_min = Vop_copy[margLCOH_min_index]
    #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

    #kg associated with min LCOH
    M_kgh2_min = M_kgh2[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

    #CAP associated with min LCOH
    M_CAP_min = M_CAPEX[margLCOH_min_index]

    #OM associated with min LCOH
    M_OM_min = M_OM[margLCOH_min_index]

#         set_trace()

    # calculate degradation amount on the Vop 
    # that minimizes margLCOH
    Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

    # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
    # the same amount 
    Vop_copy += Degradation_Amount

    Degradation_List.append(Degradation_Amount) #collect degradation amounts
#         set_trace()

    #add hourly degradation to V_plot for plotting
    #v_plot += Degradation_Amount
    #v_plot = [x + Degradation_Amount for x in v_plot]
    iv_plotting_1a.append(iv_plotting_1a[-1] + Degradation_Amount)

#         set_trace()

#                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
#                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
#                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
#                               "OptimalJop","m_kgmin"]
    data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                        margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
    LCOH_2D_data.append(data_row)

#         set_trace()


# #################################################################
# ###################################################################
#     set_trace()
#all 10 years
df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
#     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
#     set_trace()

#split into 10 years for the DCFA
df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
start = 0
stop = Life_1year
for i in range(10):
    df_LCOH_temp = df_LCOH.iloc[start:stop]
    df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
    start = stop
    stop = (i + 2) * Life_1year # cycles though each year

for df in df_LCOH_total_list:
    df.index = range(Life_1year)
#     set_trace()

   #12.28.21 - sum kg and EC for 10 years in 1 year increments
OptimalEC_List_DCFA = []
OptimalKG_List_DCFA = []
OptimalOM_List_DCFA = []
for df_LCOH in df_LCOH_total_list:
    OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
    OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
    OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))
    
#     OM_Total_1st_DCFA.append = (df_LCOH["m_OMmin"].sum())

# CAP_Total = (df_LCOH["m_CAPmin"].sum())
#     OM_Total_1st = np.nansum(df_LCOH_total_list[0]["m_OMmin"]) #first year O+M #February 7, 2022

#sum one year of hourly OM associated with minimum marginal LCOH   
#         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

#     set_trace()     

df_DCFA = pd.DataFrame(data={})
df_DCFA["Year"] = list(range(0, 11))

df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

OptimalOM_List_DCFA.insert(0, 0)
df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

OptimalEC_List_DCFA.insert(0, 0)
df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

OptimalKG_List_DCFA.insert(0, 0)
df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

#         # Calculate LCOH

PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

PV_KG = df_DCFA["PV_KG"].sum()
Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

#         # Contribution analysis

CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

df_DCFA["PV_KG"].sum()

OptimalJop_mean = []
for year in range(10):
    OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
Year1_Jop = OptimalJop_mean[0]
Year10_Jop = OptimalJop_mean[9]

#         # write to csv
print(Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, Total_CAPEX, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
print("UNINST CAPperKW:", CAPEX_per_1kW)
print("INST CAPEX:", Total_CAPEX)
print("PV_EC:", df_DCFA["PV_EC"].sum())
print("PV_KG:", PV_KG)
print("PV_OM:", df_DCFA["PV_OM"].sum())
print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
#Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode1a.csv")
df_csv

##LOW EFFICIENCY - FEB 10, 2022

#USE THIS VERSION - MODE 1A - HANDLING TERMINAL VOLTAGE 
# ##############################################
## USE THIS VERSION FOR 1A!! FEBRUARY 7, 2022
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# 

import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode1a.csv","w")
print("Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []

# runs Mode 1A for all datasets 
# # for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
# for mean in df_array_dict:
# #for mean in ["0.0"]:     
#     print("Mean Price:", mean)
# #     dfElPrice = df_array_dict[mean]

    # Technical Variables 
Jop_rated = 1.7 # A/cm2
Vop_rated = 1.8689724352687822 # Volts; #THIS CHANGES BASED ON THE IV CURVE
Capacity = 1000  # conversion factor from kW to watts
Capacity_kW = 10000 #kW
Stack_cost_1kW = 473.92 #2020 USD 
M_BOP_1kW = 150.10 #2020 USD 
E_BOP_1kW = 130.48 #2020 USD 
CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

# changing capex with current density
Electronics_percentage = 0.26 # cost increase
# for electrical balance of plant and phase separator and dryers
CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

#set_trace()

#     Jop_ = 0.1
Fit_1 = 1.4935848  #C
Fit_2 = 3.69385268 #A
Fit_3 = 0.0630398 #K

Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
#Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
#C + A * (1 - math.exp(-k * value)) for value in x

Jop = [1.7] #ONLY 1.7
# Jop as array
Jop = np.array(Jop)

# Corresponding voltages for Jops

Vop = [Y(Jop[0])] #only 1.7
# Vop as array
Vop = np.array(Vop)

# Vop_copy is a copy of Vop upon which degradation is
# applied.  So we have access to origin Vop if needed
Vop_copy = Vop.copy()

#set_trace()

#for iV curve plot
iv_plotting_1a = []
i_plot = np.linspace(0, 6, num=61)
i_plot = np.round(i_plot, 1) #rounding needs to be 1
v_plot = Y_vector(i_plot)
iv_plotting_1a.append(v_plot)

#set_trace()

#     i_plot = [0]
#     temp_y = 0
#     for i in range(60):
#         temp_y += 0.10
#         i_plot.append(round(temp_y,2))
#     v_plot = [Y(x) for x in i_plot]
#     iv_plotting.append([i_plot,v_plot])

#while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
#     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
#     Vop_ = Y(Jop_) 

n_mol = 2  # constant for H2
F = 96485  # Faraday's constant
V_threshold = 2.9  # voltage at which current removed from options

N_life = 10  # life of electrolyzer

DR = 0.10  # discount rate

# vary A/cm2 in 0.1 increments 0 to 6.0 
#     Jop = [Jop_] 
#     print("Jop:",Jop[0])

#     Vop = [Vop_] #1.79
#     print("Vop:",Vop[0])

#     PReq = []  # kW required per hour
#     for i in range(len(Jop)):  
#         if Jop[i] != 0:
#             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
#         else:
#             PReq.append(0)

# degrade voltage
Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
# every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

# prevents Jop[i] and Vop[i] from being modified
#     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

#         if Jop[i] != 0:
#             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
#         else:
#             PReq[i] = 0
#         return PReq[i]

#12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
M_CAPEX = []  # varying the CAPEX_Electronics with Jop
for k in range(len(Jop)):
    if Jop[k] > 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop[k]*Vop[k]/1000
        Installation_Factor = 1.19 #Installed CAPEX 
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    elif Jop[k] > 0 and Jop[k] <= 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
        Installation_Factor = 1.19
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    else:
        M_CAPEX.append(0)  

# array
M_CAPEX = np.array(M_CAPEX)

M_OM = [x*0.05 for x in M_CAPEX] 

#array
M_OM = np.array(M_OM)

# Rate of fuel production in kg every hour of year 1
M_kgh2 = []
for k in range(len(Jop)):
    if Jop[k] != 0:
        M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
    else:
        M_kgh2.append(0)  # 0 kg produced when Jop=0

# array
M_kg2 = np.array(M_kgh2)

#12.28.21 - LCOH column names list
LCOH_column_names = []
LCOH_2D_data = [] #box

for i in range(len(Jop)):
    LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
    LCOH_column_names.append(name)

break_point = None #to determine hour at which electrolyzer dies
hour = 0
for price in dfElPrice:
#     for price in dfElPrice:  
    # Preq is a numpy array
    hour+=1     
    #Make EC NAN if terminal voltage is reached - Feb 7, 2022
    # if Vop is > Vthreshold make EC NAN
    if Vop_copy >= V_threshold:
        if break_point == None:
            break_point = hour 
        #determine when EOL reached with hour variable
        EC = [np.nan for i in Jop] #must be an array
        EC = np.array(EC)
    else:
        EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage #EC is an array
        
#     set_trace()

    # if EC is NAN then make the corresponding elements NAN - for terminal voltage
    # in M_kg2, M_CAPEX and M_OM

    M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
#     M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
    M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

    #set_trace()

    # array - create marginal LCOH for each Jop; if kg = 0 make nan; maringal LCOH will be NAN if EC is NaN 
    marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

    #set_trace()

    #marginal LCOH per Jop
    # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
    #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
    #LCOH_hourly_data.append(marginal_LCOH_value)

#                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
#         for df_LCOH in df_LCOH_total_list:  

    #minimum LCOH per hour - ignore nan values
    margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
    margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
    #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

    #set_trace()

    #Energy charge minimum
    EC_min = EC[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

    #Jop that minimizes marginal LCOH  and corresponding Vop
    Jop_min = Jop[margLCOH_min_index]
    Vop_copy_min = Vop_copy[margLCOH_min_index]
    #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

    #kg associated with min LCOH
    M_kgh2_min = M_kgh2[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

    #CAP associated with min LCOH
    M_CAP_min = M_CAPEX[margLCOH_min_index]

    #OM associated with min LCOH
    M_OM_min = M_OM[margLCOH_min_index]

#         set_trace()

    # calculate degradation amount on the Vop 
    # that minimizes margLCOH
    Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

    # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
    # the same amount 
    Vop_copy += Degradation_Amount

    Degradation_List.append(Degradation_Amount) #collect degradation amounts
#         set_trace()

    #add hourly degradation to V_plot for plotting
    #v_plot += Degradation_Amount
    #v_plot = [x + Degradation_Amount for x in v_plot]
    iv_plotting_1a.append(iv_plotting_1a[-1] + Degradation_Amount)

#         set_trace()

#                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
#                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
#                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
#                               "OptimalJop","m_kgmin"]
    data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                        margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
    LCOH_2D_data.append(data_row)

#         set_trace()


# #################################################################
# ###################################################################
#     set_trace()
#all 10 years
df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
#     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
#     set_trace()

#split into 10 years for the DCFA
df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
start = 0
stop = Life_1year
for i in range(10):
    df_LCOH_temp = df_LCOH.iloc[start:stop]
    df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
    start = stop
    stop = (i + 2) * Life_1year # cycles though each year

for df in df_LCOH_total_list:
    df.index = range(Life_1year)
#     set_trace()

   #12.28.21 - sum kg and EC for 10 years in 1 year increments
OptimalEC_List_DCFA = []
OptimalKG_List_DCFA = []
OptimalOM_List_DCFA = []
for df_LCOH in df_LCOH_total_list:
    OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
    OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
    OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))
    
#     OM_Total_1st_DCFA.append = (df_LCOH["m_OMmin"].sum())

# CAP_Total = (df_LCOH["m_CAPmin"].sum())
#     OM_Total_1st = np.nansum(df_LCOH_total_list[0]["m_OMmin"]) #first year O+M #February 7, 2022

#sum one year of hourly OM associated with minimum marginal LCOH   
#         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

#     set_trace()     

df_DCFA = pd.DataFrame(data={})
df_DCFA["Year"] = list(range(0, 11))

df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

OptimalOM_List_DCFA.insert(0, 0)
df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

OptimalEC_List_DCFA.insert(0, 0)
df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

OptimalKG_List_DCFA.insert(0, 0)
df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

#         # Calculate LCOH

PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

PV_KG = df_DCFA["PV_KG"].sum()
Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

#         # Contribution analysis

CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

df_DCFA["PV_KG"].sum()

OptimalJop_mean = []
for year in range(10):
    OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
Year1_Jop = OptimalJop_mean[0]
Year10_Jop = OptimalJop_mean[9]

#         # write to csv
print(Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, Total_CAPEX, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
print("UNINST CAPperKW:", CAPEX_per_1kW)
print("INST CAPEX:", Total_CAPEX)
print("PV_EC:", df_DCFA["PV_EC"].sum())
print("PV_KG:", PV_KG)
print("PV_OM:", df_DCFA["PV_OM"].sum())
print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
#Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode1a.csv")
df_csv

##USE THIS VERSION - MODE 1A - HANDLING TERMINAL VOLTAGE  - BASELINE EFFICIENCY
# ##############################################
## USE THIS VERSION FOR 1A!! FEBRUARY 7, 2022
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# 

import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode1a.csv","w")
print("Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []

# runs Mode 1A for all datasets 
# # for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
# for mean in df_array_dict:
# #for mean in ["0.0"]:     
#     print("Mean Price:", mean)
# #     dfElPrice = df_array_dict[mean]

    # Technical Variables 
Jop_rated = 1.7 # A/cm2
Vop_rated = 1.75292048 # Volts
Capacity = 1000  # conversion factor from kW to watts
Capacity_kW = 10000 #kW
Stack_cost_1kW = 473.92 #2020 USD 
M_BOP_1kW = 150.10 #2020 USD 
E_BOP_1kW = 130.48 #2020 USD 
CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5
# CAPEX_per_1kW = 249.58 #low
# CAPEX_per_1kW = 1091.59663 #high
    
# changing capex with current density
Electronics_percentage = 0.26 # cost increase
# for electrical balance of plant and phase separator and dryers
CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

#set_trace()

#     Jop_ = 0.1
Fit_1 = 1.44926681  #C
Fit_2 = 2.71725674 #A
Fit_3 = 0.06970714 #K

Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
#Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
#C + A * (1 - math.exp(-k * value)) for value in x

Jop = [1.7] #ONLY 1.7
# Jop as array
Jop = np.array(Jop)

# Corresponding voltages for Jops

Vop = [Y(Jop[0])] #only 1.7
# Vop as array
Vop = np.array(Vop)

# Vop_copy is a copy of Vop upon which degradation is
# applied.  So we have access to origin Vop if needed
Vop_copy = Vop.copy()

#set_trace()

#for iV curve plot
iv_plotting_1a = []
i_plot = np.linspace(0, 6, num=61)
i_plot = np.round(i_plot, 1) #rounding needs to be 1
v_plot = Y_vector(i_plot)
iv_plotting_1a.append(v_plot)

#set_trace()

#     i_plot = [0]
#     temp_y = 0
#     for i in range(60):
#         temp_y += 0.10
#         i_plot.append(round(temp_y,2))
#     v_plot = [Y(x) for x in i_plot]
#     iv_plotting.append([i_plot,v_plot])

#while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
#     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
#     Vop_ = Y(Jop_) 

n_mol = 2  # constant for H2
F = 96485  # Faraday's constant
V_threshold = 2.9  # voltage at which current removed from options

N_life = 10  # life of electrolyzer

DR = 0.10  # discount rate

# vary A/cm2 in 0.1 increments 0 to 6.0 
#     Jop = [Jop_] 
#     print("Jop:",Jop[0])

#     Vop = [Vop_] #1.79
#     print("Vop:",Vop[0])

#     PReq = []  # kW required per hour
#     for i in range(len(Jop)):  
#         if Jop[i] != 0:
#             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
#         else:
#             PReq.append(0)

# degrade voltage
Degradation_Rate = 0.0005 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
# every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

# prevents Jop[i] and Vop[i] from being modified
#     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

#         if Jop[i] != 0:
#             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
#         else:
#             PReq[i] = 0
#         return PReq[i]

#12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
M_CAPEX = []  # varying the CAPEX_Electronics with Jop
for k in range(len(Jop)):
    if Jop[k] > 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop[k]*Vop[k]/1000
        Installation_Factor = 1.19 #Installed CAPEX 
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    elif Jop[k] > 0 and Jop[k] <= 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
        Installation_Factor = 1.19
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    else:
        M_CAPEX.append(0)  

# array
M_CAPEX = np.array(M_CAPEX)

M_OM = [x*0.05 for x in M_CAPEX] 

#array
M_OM = np.array(M_OM)

# Rate of fuel production in kg every hour of year 1
M_kgh2 = []
for k in range(len(Jop)):
    if Jop[k] != 0:
        M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
    else:
        M_kgh2.append(0)  # 0 kg produced when Jop=0

# array
M_kg2 = np.array(M_kgh2)

#12.28.21 - LCOH column names list
LCOH_column_names = []
LCOH_2D_data = [] #box

for i in range(len(Jop)):
    LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
    LCOH_column_names.append(name)

break_point = None #to determine hour at which electrolyzer dies
hour = 0
for price in dfElPrice:
#     for price in dfElPrice:  
    # Preq is a numpy array
    hour+=1     
    #Make EC NAN if terminal voltage is reached - Feb 7, 2022
    # if Vop is > Vthreshold make EC NAN
    if Vop_copy >= V_threshold:
        if break_point == None:
            break_point = hour 
        #determine when EOL reached with hour variable
        EC = [np.nan for i in Jop] #must be an array
        EC = np.array(EC)
    else:
        EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage #EC is an array
        
#     set_trace()

    # if EC is NAN then make the corresponding elements NAN - for terminal voltage
    # in M_kg2, M_CAPEX and M_OM

    M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
#     M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
    M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

    #set_trace()

    # array - create marginal LCOH for each Jop; if kg = 0 make nan; maringal LCOH will be NAN if EC is NaN 
    marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

    #set_trace()

    #marginal LCOH per Jop
    # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
    #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
    #LCOH_hourly_data.append(marginal_LCOH_value)

#                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
#         for df_LCOH in df_LCOH_total_list:  

    #minimum LCOH per hour - ignore nan values
    margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
    margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
    #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

    #set_trace()

    #Energy charge minimum
    EC_min = EC[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

    #Jop that minimizes marginal LCOH  and corresponding Vop
    Jop_min = Jop[margLCOH_min_index]
    Vop_copy_min = Vop_copy[margLCOH_min_index]
    #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

    #kg associated with min LCOH
    M_kgh2_min = M_kgh2[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

    #CAP associated with min LCOH
    M_CAP_min = M_CAPEX[margLCOH_min_index]

    #OM associated with min LCOH
    M_OM_min = M_OM[margLCOH_min_index]

#         set_trace()

    # calculate degradation amount on the Vop 
    # that minimizes margLCOH
    Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

    # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
    # the same amount 
    Vop_copy += Degradation_Amount

    Degradation_List.append(Degradation_Amount) #collect degradation amounts
#         set_trace()

    #add hourly degradation to V_plot for plotting
    #v_plot += Degradation_Amount
    #v_plot = [x + Degradation_Amount for x in v_plot]
    iv_plotting_1a.append(iv_plotting_1a[-1] + Degradation_Amount)

#         set_trace()

#                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
#                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
#                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
#                               "OptimalJop","m_kgmin"]
    data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                        margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
    LCOH_2D_data.append(data_row)

#         set_trace()


# #################################################################
# ###################################################################
#     set_trace()
#all 10 years
df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
#     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
#     set_trace()

#split into 10 years for the DCFA
df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
start = 0
stop = Life_1year
for i in range(10):
    df_LCOH_temp = df_LCOH.iloc[start:stop]
    df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
    start = stop
    stop = (i + 2) * Life_1year # cycles though each year

for df in df_LCOH_total_list:
    df.index = range(Life_1year)
#     set_trace()

   #12.28.21 - sum kg and EC for 10 years in 1 year increments
OptimalEC_List_DCFA = []
OptimalKG_List_DCFA = []
OptimalOM_List_DCFA = []
for df_LCOH in df_LCOH_total_list:
    OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
    OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
    OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))
    
#     OM_Total_1st_DCFA.append = (df_LCOH["m_OMmin"].sum())

# CAP_Total = (df_LCOH["m_CAPmin"].sum())
#     OM_Total_1st = np.nansum(df_LCOH_total_list[0]["m_OMmin"]) #first year O+M #February 7, 2022

#sum one year of hourly OM associated with minimum marginal LCOH   
#         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

#     set_trace()     

df_DCFA = pd.DataFrame(data={})
df_DCFA["Year"] = list(range(0, 11))

df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

OptimalOM_List_DCFA.insert(0, 0)
df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

OptimalEC_List_DCFA.insert(0, 0)
df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

OptimalKG_List_DCFA.insert(0, 0)
df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

#         # Calculate LCOH

PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

PV_KG = df_DCFA["PV_KG"].sum()
Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

#         # Contribution analysis

CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

df_DCFA["PV_KG"].sum()

OptimalJop_mean = []
for year in range(10):
    OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
Year1_Jop = OptimalJop_mean[0]
Year10_Jop = OptimalJop_mean[9]

#         # write to csv
print(Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, Total_CAPEX, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
print("UNINST CAPperKW:", CAPEX_per_1kW)
print("INST CAPEX:", Total_CAPEX)
print("PV_EC:", df_DCFA["PV_EC"].sum())
print("PV_KG:", PV_KG)
print("PV_OM:", df_DCFA["PV_OM"].sum())
print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
#Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode1a.csv")
df_csv

##ALL means - March 5, 2022
#USE THIS VERSION - MODE 1A - HANDLING TERMINAL VOLTAGE  - BASELINE EFFICIENCY
# ##############################################
## USE THIS VERSION FOR 1A!! FEBRUARY 7, 2022
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# 

import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode1a.csv","w")
print("Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []

# runs Mode 1A for all datasets 
# # for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
for mean in df_array_dict:
# #for mean in ["0.0"]:     
    print("Mean Price:", mean)
    dfElPrice = df_array_dict[mean]

    # Technical Variables 
    Jop_rated = 1.7 # A/cm2
    Vop_rated = 1.75292048 # Volts
    Capacity = 1000  # conversion factor from kW to watts
    Capacity_kW = 10000 #kW
    Stack_cost_1kW = 473.92 #2020 USD 
    M_BOP_1kW = 150.10 #2020 USD 
    E_BOP_1kW = 130.48 #2020 USD 
    CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

    # changing capex with current density
    Electronics_percentage = 0.26 # cost increase
    # for electrical balance of plant and phase separator and dryers
    CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
    CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
    A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
    CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

    #set_trace()

    #     Jop_ = 0.1
    Fit_1 = 1.44926681  #C
    Fit_2 = 2.71725674 #A
    Fit_3 = 0.06970714 #K

    Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
    Y_vector = np.vectorize(Y)
    #Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
    #C + A * (1 - math.exp(-k * value)) for value in x

    Jop = [1.7] #ONLY 1.7
    # Jop as array
    Jop = np.array(Jop)

    # Corresponding voltages for Jops

    Vop = [Y(Jop[0])] #only 1.7
    # Vop as array
    Vop = np.array(Vop)

    # Vop_copy is a copy of Vop upon which degradation is
    # applied.  So we have access to origin Vop if needed
    Vop_copy = Vop.copy()

    #set_trace()

    #for iV curve plot
    iv_plotting_1a = []
    i_plot = np.linspace(0, 6, num=61)
    i_plot = np.round(i_plot, 1) #rounding needs to be 1
    v_plot = Y_vector(i_plot)
    iv_plotting_1a.append(v_plot)

    #set_trace()

    #     i_plot = [0]
    #     temp_y = 0
    #     for i in range(60):
    #         temp_y += 0.10
    #         i_plot.append(round(temp_y,2))
    #     v_plot = [Y(x) for x in i_plot]
    #     iv_plotting.append([i_plot,v_plot])

    #while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
    #     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
    #     Vop_ = Y(Jop_) 

    n_mol = 2  # constant for H2
    F = 96485  # Faraday's constant
    V_threshold = 2.9  # voltage at which current removed from options

    N_life = 10  # life of electrolyzer

    DR = 0.10  # discount rate

    # vary A/cm2 in 0.1 increments 0 to 6.0 
    #     Jop = [Jop_] 
    #     print("Jop:",Jop[0])

    #     Vop = [Vop_] #1.79
    #     print("Vop:",Vop[0])

    #     PReq = []  # kW required per hour
    #     for i in range(len(Jop)):  
    #         if Jop[i] != 0:
    #             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
    #         else:
    #             PReq.append(0)

    # degrade voltage
    Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
    # every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

    # prevents Jop[i] and Vop[i] from being modified
    #     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

    #         if Jop[i] != 0:
    #             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
    #         else:
    #             PReq[i] = 0
    #         return PReq[i]

    #12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
    M_CAPEX = []  # varying the CAPEX_Electronics with Jop
    for k in range(len(Jop)):
        if Jop[k] > 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop[k]*Vop[k]/1000
            Installation_Factor = 1.19 #Installed CAPEX 
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        elif Jop[k] > 0 and Jop[k] <= 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
            Installation_Factor = 1.19
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        else:
            M_CAPEX.append(0)  

    # array
    M_CAPEX = np.array(M_CAPEX)

    M_OM = [x*0.05 for x in M_CAPEX] 

    #array
    M_OM = np.array(M_OM)

    # Rate of fuel production in kg every hour of year 1
    M_kgh2 = []
    for k in range(len(Jop)):
        if Jop[k] != 0:
            M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
        else:
            M_kgh2.append(0)  # 0 kg produced when Jop=0

    # array
    M_kg2 = np.array(M_kgh2)

    #12.28.21 - LCOH column names list
    LCOH_column_names = []
    LCOH_2D_data = [] #box

    for i in range(len(Jop)):
        LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

    for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
        LCOH_column_names.append(name)

    break_point = None #to determine hour at which electrolyzer dies
    hour = 0
    for price in dfElPrice:
    #     for price in dfElPrice:  
        # Preq is a numpy array
        hour+=1     
        #Make EC NAN if terminal voltage is reached - Feb 7, 2022
        # if Vop is > Vthreshold make EC NAN
        if Vop_copy >= V_threshold:
            if break_point == None:
                break_point = hour 
            #determine when EOL reached with hour variable
            EC = [np.nan for i in Jop] #must be an array
            EC = np.array(EC)
        else:
            EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage #EC is an array

    #     set_trace()

        # if EC is NAN then make the corresponding elements NAN - for terminal voltage
        # in M_kg2, M_CAPEX and M_OM

        M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
    #     M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
        M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

        #set_trace()

        # array - create marginal LCOH for each Jop; if kg = 0 make nan; maringal LCOH will be NAN if EC is NaN 
        marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

        #set_trace()

        #marginal LCOH per Jop
        # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
        #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
        #LCOH_hourly_data.append(marginal_LCOH_value)

    #                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
    #         for df_LCOH in df_LCOH_total_list:  

        #minimum LCOH per hour - ignore nan values
        margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
        margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
        #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

        #set_trace()

        #Energy charge minimum
        EC_min = EC[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

        #Jop that minimizes marginal LCOH  and corresponding Vop
        Jop_min = Jop[margLCOH_min_index]
        Vop_copy_min = Vop_copy[margLCOH_min_index]
        #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

        #kg associated with min LCOH
        M_kgh2_min = M_kgh2[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

        #CAP associated with min LCOH
        M_CAP_min = M_CAPEX[margLCOH_min_index]

        #OM associated with min LCOH
        M_OM_min = M_OM[margLCOH_min_index]

    #         set_trace()

        # calculate degradation amount on the Vop 
        # that minimizes margLCOH
        Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

        # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
        # the same amount 
        Vop_copy += Degradation_Amount

        Degradation_List.append(Degradation_Amount) #collect degradation amounts
    #         set_trace()

        #add hourly degradation to V_plot for plotting
        #v_plot += Degradation_Amount
        #v_plot = [x + Degradation_Amount for x in v_plot]
        iv_plotting_1a.append(iv_plotting_1a[-1] + Degradation_Amount)

    #         set_trace()

    #                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
    #                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
    #                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
    #                               "OptimalJop","m_kgmin"]
        data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                            margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
        LCOH_2D_data.append(data_row)

    #         set_trace()


    # #################################################################
    # ###################################################################
    #     set_trace()
    #all 10 years
    df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
    CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
    #     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
    #     set_trace()

    #split into 10 years for the DCFA
    df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
    start = 0
    stop = Life_1year
    for i in range(10):
        df_LCOH_temp = df_LCOH.iloc[start:stop]
        df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
        start = stop
        stop = (i + 2) * Life_1year # cycles though each year

    for df in df_LCOH_total_list:
        df.index = range(Life_1year)
    #     set_trace()

       #12.28.21 - sum kg and EC for 10 years in 1 year increments
    OptimalEC_List_DCFA = []
    OptimalKG_List_DCFA = []
    OptimalOM_List_DCFA = []
    for df_LCOH in df_LCOH_total_list:
        OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
        OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
        OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))

    #     OM_Total_1st_DCFA.append = (df_LCOH["m_OMmin"].sum())

    # CAP_Total = (df_LCOH["m_CAPmin"].sum())
    #     OM_Total_1st = np.nansum(df_LCOH_total_list[0]["m_OMmin"]) #first year O+M #February 7, 2022

    #sum one year of hourly OM associated with minimum marginal LCOH   
    #         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

    #     set_trace()     

    df_DCFA = pd.DataFrame(data={})
    df_DCFA["Year"] = list(range(0, 11))

    df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

    df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

    OptimalOM_List_DCFA.insert(0, 0)
    df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalEC_List_DCFA.insert(0, 0)
    df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalKG_List_DCFA.insert(0, 0)
    df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    #         # Calculate LCOH

    PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

    PV_KG = df_DCFA["PV_KG"].sum()
    Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

    #         # Contribution analysis

    CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

    OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

    EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

    df_DCFA["PV_KG"].sum()

    OptimalJop_mean = []
    for year in range(10):
        OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
    Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
    Year1_Jop = OptimalJop_mean[0]
    Year10_Jop = OptimalJop_mean[9]

    #         # write to csv
    print(Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, Total_CAPEX, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
    print("UNINST CAPperKW:", CAPEX_per_1kW)
    print("INST CAPEX:", Total_CAPEX)
    print("PV_EC:", df_DCFA["PV_EC"].sum())
    print("PV_KG:", PV_KG)
    print("PV_OM:", df_DCFA["PV_OM"].sum())
    print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
#Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode1a.csv")
df_csv

df_DCFA

break_point

print("break point hour:", (break_point-1))
EOL = ((break_point-1)/Life_1year)+1
EOL

##Feb 8, 2022 - Testing constant price - 1A
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# 

import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode1a.csv","w")
print("Mean Price","Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []

# runs Mode 1A for all datasets 
for mean in ['0.0', '0.01', '0.02', '0.03', '0.04', '0.05', '0.06', '0.07']:     #for mean in df_array_dict:
# for mean in df_array_dict:
#for mean in ["0.0"]:     
    print("Mean Price:", mean)
    dfElPrice = df_array_dict[mean]
#     dfElPrice = dfElPrice_const_dict[mean]

        # Technical Variables 
    Jop_rated = 1.7 # A/cm2
    Vop_rated = 1.75292048 # Volts
    Capacity = 1000  # conversion factor from kW to watts
    Capacity_kW = 10000 #kW
    Stack_cost_1kW = 473.92 #2020 USD 
    M_BOP_1kW = 150.10 #2020 USD 
    E_BOP_1kW = 130.48 #2020 USD 
    CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

    # changing capex with current density
    Electronics_percentage = 0.26 # cost increase
    # for electrical balance of plant and phase separator and dryers
    CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
    CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
    A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
    CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

    #set_trace()

    #     Jop_ = 0.1
    Fit_1 = 1.44926681  #C
    Fit_2 = 2.71725674 #A
    Fit_3 = 0.06970714 #K
    Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
    Y_vector = np.vectorize(Y)
    #Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
    #C + A * (1 - math.exp(-k * value)) for value in x

    Jop = [1.7] #ONLY 1.7
    # Jop as array
    Jop = np.array(Jop)

    # Corresponding voltages for Jops

    Vop = [Y(Jop[0])] #only 1.7
    # Vop as array
    Vop = np.array(Vop)

    # Vop_copy is a copy of Vop upon which degradation is
    # applied.  So we have access to origin Vop if needed
    Vop_copy = Vop.copy()

    #set_trace()

    #for iV curve plot
    iv_plotting_1a = []
    i_plot = np.linspace(0, 6, num=61)
    i_plot = np.round(i_plot, 1) #rounding needs to be 1
    v_plot = Y_vector(i_plot)
    iv_plotting_1a.append(v_plot)

    #set_trace()

    #     i_plot = [0]
    #     temp_y = 0
    #     for i in range(60):
    #         temp_y += 0.10
    #         i_plot.append(round(temp_y,2))
    #     v_plot = [Y(x) for x in i_plot]
    #     iv_plotting.append([i_plot,v_plot])

    #while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
    #     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
    #     Vop_ = Y(Jop_) 

    n_mol = 2  # constant for H2
    F = 96485  # Faraday's constant
    V_threshold = 2.9  # voltage at which current removed from options

    N_life = 10  # life of electrolyzer

    DR = 0.10  # discount rate

    # vary A/cm2 in 0.1 increments 0 to 6.0 
    #     Jop = [Jop_] 
    #     print("Jop:",Jop[0])

    #     Vop = [Vop_] #1.79
    #     print("Vop:",Vop[0])

    #     PReq = []  # kW required per hour
    #     for i in range(len(Jop)):  
    #         if Jop[i] != 0:
    #             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
    #         else:
    #             PReq.append(0)

    # degrade voltage
    Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
    # every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

    # prevents Jop[i] and Vop[i] from being modified
    #     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

    #         if Jop[i] != 0:
    #             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
    #         else:
    #             PReq[i] = 0
    #         return PReq[i]

    #12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
    M_CAPEX = []  # varying the CAPEX_Electronics with Jop
    for k in range(len(Jop)):
        if Jop[k] > 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop[k]*Vop[k]/1000
            Installation_Factor = 1.19 #Installed CAPEX 
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        elif Jop[k] > 0 and Jop[k] <= 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
            Installation_Factor = 1.19
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        else:
            M_CAPEX.append(0)  

    # array
    M_CAPEX = np.array(M_CAPEX)

    M_OM = [x*0.05 for x in M_CAPEX] 

    #array
    M_OM = np.array(M_OM)

    # Rate of fuel production in kg every hour of year 1
    M_kgh2 = []
    for k in range(len(Jop)):
        if Jop[k] != 0:
            M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
        else:
            M_kgh2.append(0)  # 0 kg produced when Jop=0

    # array
    M_kg2 = np.array(M_kgh2)

    #12.28.21 - LCOH column names list
    LCOH_column_names = []
    LCOH_2D_data = [] #box

    for i in range(len(Jop)):
        LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

    for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
        LCOH_column_names.append(name)

    break_point = None #to determine hour at which electrolyzer dies
    hour = 0
    for price in dfElPrice:
    #     for price in dfElPrice:  
        # Preq is a numpy array
        hour+=1     
        #Make EC NAN if terminal voltage is reached - Feb 7, 2022
        # if Vop is > Vthreshold make EC NAN
        if Vop_copy >= V_threshold:
            if break_point == None:
                break_point = hour 
            #determine when EOL reached with hour variable
            EC = [np.nan for i in Jop] #must be an array
            EC = np.array(EC)
        else:
            EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage #EC is an array

    #     set_trace()

        # if EC is NAN then make the corresponding elements NAN - for terminal voltage
        # in M_kg2, M_CAPEX and M_OM

        M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
    #     M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
        M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

        #set_trace()

        # array - create marginal LCOH for each Jop; if kg = 0 make nan; maringal LCOH will be NAN if EC is NaN 
        marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

        #set_trace()

        #marginal LCOH per Jop
        # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
        #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
        #LCOH_hourly_data.append(marginal_LCOH_value)

    #                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
    #         for df_LCOH in df_LCOH_total_list:  

        #minimum LCOH per hour - ignore nan values
        margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
        margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
        #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

        #set_trace()

        #Energy charge minimum
        EC_min = EC[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

        #Jop that minimizes marginal LCOH  and corresponding Vop
        Jop_min = Jop[margLCOH_min_index]
        Vop_copy_min = Vop_copy[margLCOH_min_index]
        #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

        #kg associated with min LCOH
        M_kgh2_min = M_kgh2[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

        #CAP associated with min LCOH
        M_CAP_min = M_CAPEX[margLCOH_min_index]

        #OM associated with min LCOH
        M_OM_min = M_OM[margLCOH_min_index]

    #         set_trace()

        # calculate degradation amount on the Vop 
        # that minimizes margLCOH
        Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

        # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
        # the same amount 
        Vop_copy += Degradation_Amount

        Degradation_List.append(Degradation_Amount) #collect degradation amounts
    #         set_trace()

        #add hourly degradation to V_plot for plotting
        #v_plot += Degradation_Amount
        #v_plot = [x + Degradation_Amount for x in v_plot]
        iv_plotting_1a.append(iv_plotting_1a[-1] + Degradation_Amount)

    #         set_trace()

    #                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
    #                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
    #                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
    #                               "OptimalJop","m_kgmin"]
        data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                            margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
        LCOH_2D_data.append(data_row)

    #         set_trace()


    # #################################################################
    # ###################################################################
    #     set_trace()
    #all 10 years
    df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
    CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
    #     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
    #     set_trace()

    #split into 10 years for the DCFA
    df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
    start = 0
    stop = Life_1year
    for i in range(10):
        df_LCOH_temp = df_LCOH.iloc[start:stop]
        df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
        start = stop
        stop = (i + 2) * Life_1year # cycles though each year

    for df in df_LCOH_total_list:
        df.index = range(Life_1year)
    #     set_trace()

       #12.28.21 - sum kg and EC for 10 years in 1 year increments
    OptimalEC_List_DCFA = []
    OptimalKG_List_DCFA = []
    OptimalOM_List_DCFA = []
    for df_LCOH in df_LCOH_total_list:
        OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
        OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
        OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))

    #     OM_Total_1st_DCFA.append = (df_LCOH["m_OMmin"].sum())

    # CAP_Total = (df_LCOH["m_CAPmin"].sum())
    #     OM_Total_1st = np.nansum(df_LCOH_total_list[0]["m_OMmin"]) #first year O+M #February 7, 2022

    #sum one year of hourly OM associated with minimum marginal LCOH   
    #         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

    #     set_trace()     

    df_DCFA = pd.DataFrame(data={})
    df_DCFA["Year"] = list(range(0, 11))

    df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

    df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

    OptimalOM_List_DCFA.insert(0, 0)
    df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalEC_List_DCFA.insert(0, 0)
    df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalKG_List_DCFA.insert(0, 0)
    df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    #         # Calculate LCOH

    PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

    PV_KG = df_DCFA["PV_KG"].sum()
    Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

    #         # Contribution analysis

    CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

    OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

    EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

    df_DCFA["PV_KG"].sum()

    OptimalJop_mean = []
    for year in range(10):
        OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
    Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
    Year1_Jop = OptimalJop_mean[0]
    Year10_Jop = OptimalJop_mean[9]

#         # write to csv
    print(mean, Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, Total_CAPEX, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
    print("UNINST CAPperKW:", CAPEX_per_1kW)
    print("INST CAPEX:", Total_CAPEX)
    print("PV_EC:", df_DCFA["PV_EC"].sum())
    print("PV_KG:", PV_KG)
    print("PV_OM:", df_DCFA["PV_OM"].sum())
    print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
    #Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode1a.csv")
df_csv

#to get the last voltage of the iV curve  - Feb 7, 2022
iv_plotting_1a[break_point-1][17] #terminal voltage for 1.7 A/cm2
# 2.900028962452506

print("break point hour:", (break_point-1))
EOL = ((break_point-1)/Life_1year)+1
EOL

# Commented out IPython magic to ensure Python compatibility.
#THIS WORKS!!
# %matplotlib notebook 
for hour in range(0,Life_hours,8783): 
    plt.plot(i_plot,iv_plotting_1a[hour])

for x,y in zip(break_point_dictionary["5.9"][0],break_point_dictionary["5.9"][1]):
    if x == None:
        break_year = np.nan
    else:
        break_year = round((x/Life_hours)+1,2)
    print(x,round(y,2),break_year)

for x,y in zip(break_point_dictionary["6.0"][0],break_point_dictionary["6.0"][1]):
    if x == None:
        break_year = np.nan
    else:
        break_year = round((x/Life_hours)+1,2)
    print(x,round(y,2),break_year)

for x,y in zip(break_point_dictionary["6.0"],Jop):
    if x == None:
        break_point_years = np.nan
    else:
        break_point_years = round((x/Life_hours)+1,2)
    print(x,round(y,2), break_point_years)

"""# Degradation"""

#to analyze voltage degradation
degradation_voltages_csv = {}
degradation_voltages_csv["Jop"] = i_plot
for hour in range(0,Life_hours,8759): 
    degradation_voltages_csv[str(hour)] = iv_plotting[hour]

df_degradation_voltages = pd.DataFrame(data=degradation_voltages_csv)
df_degradation_voltages

df_degradation_voltages.to_csv("degraded_voltages_mode3.csv")

#2A
Jop_ = 0.1
Fit_1 = 1.44926681  #C
Fit_2 = 2.71725674 #A
Fit_3 = 0.06970714 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)

Jop = [0,0.1,1.7] 
# Jop as array
Jop = np.array(Jop)

# Corresponding voltages for Jops

Vop = [Y(Jop[0]), Y(Jop[1]), Y(Jop[2])]
# Vop as array
Vop = np.array(Vop)

Vop_copy = Vop.copy()
#for iV curve plot
iv_plotting_2a = []
i_plot = np.linspace(0, 6, num=61)
print(len(i_plot))
i_plot = np.round(i_plot, 1)
print(len(i_plot))
v_plot = Y_vector(i_plot)
iv_plotting_2a.append(v_plot)
len(i_plot)
print(i_plot)

print(iv_plotting_1a[0][1])
print(iv_plotting_2a[0])

# Commented out IPython magic to ensure Python compatibility.
#compare 1a and 2a baseline iv curves
from matplotlib import pyplot as plt
# %matplotlib notebook 
plt.plot(iv_plotting_1a[0][0], iv_plotting_1a[0][1]) #hour 0, Jop, hour 0 Vop
plt.plot(i_plot, iv_plotting_2a[0]) #hour 0, Vop 
plt.show()

print(iv_plotting_1a[0][1])
print(iv_plotting[0])

# Commented out IPython magic to ensure Python compatibility.
#checking degradation amounts of vop variables for first hour along iV curve (60 values per mode) - differences between Mode 1A and 2A
#y1 is mode 1A vop, y2 is mode 2A vop
# %matplotlib notebook 
# mode_1a_y1 = [] 
# mode_2a_y2 = []
# for (y1,y2) in zip(mode_1a_iv_plotting[0][1],iv_plotting[0]): #in mode 1a hour is the first index, in mode 2A, hr is first index
#     mode_1a_y1.append(y1)
#     mode_2a_y2.append(y2)

# plt.plot(mode_1a_y1, mode_2a_y2) #shows iV curve of mode 1A in hr 1 and iV curve of Mode 2A in hr 1
# plt.plot(i_plot, mode_1a_y1)
# plt.plot(i_plot, mode_2a_y2)

# Logic: Mode 1A should be higher iV curve at end of life because always 1.7 A/cm2
#     Mode 2A can be 0.1 A/cm2
    
plt.plot(i_plot, iv_plotting_1a[85000],"b")
plt.plot(i_plot, iv_plotting[85000],"r")

print(mode_1a_y1)

print(mode_2a_y2)

mode_1a_iv_plotting[0][1]
1.44926681, 1.46814217, 1.4868864 , 1.50735471

iv_plotting[0]

mode_1a_y1

mode_2a_y2

i_plot

mode_1a_iv_plotting[Life_hours-1][1]

iv_plotting[Life_hours-1]

# Commented out IPython magic to ensure Python compatibility.
#checking degradation amounts of vop variables for first hour along iV curve (60 values per mode) - differences between Mode 1A and 2A
#y1 is mode 1A vop, y2 is mode 2A vop
# %matplotlib notebook 
mode_1a_y1 = [] 
mode_2a_y2 = []
for (y1,y2) in zip(mode_1a_iv_plotting[Life_hours-1][1],iv_plotting[Life_hours-1]): #in mode 1a hour is the first index, in mode 2A, hr is first index
    mode_1a_y1.append(y1)
    mode_2a_y2.append(y2)

# plt.plot(mode_1a_y1, mode_2a_y2) #shows iV curve of mode 1A in hr 1 and iV curve of Mode 2A in hr 1
plt.plot(i_plot, mode_1a_y1)
plt.plot(i_plot, mode_2a_y2)

#error checking
x = df_LCOH["mLCOH_Jop1.7"] == df_LCOH["mLCOH_min"]   
x.describe()

Degradation_List #degradation amounts every hour

df_degradation = pd.DataFrame(data=Degradation_List,columns=["A"])
df_degradation["A"].value_counts()

#for plotting iv curve
#first index is hr, second index is current and voltage
#baseline:
plt.plot(iv_plotting[0][0],iv_plotting[0][1]) #first hour, current, first hour voltage
plt.xlabel("Current density (A/cm2)")
plt.ylabel("Operating voltage (V)")
plt.title("Mode 1A IV curve over time (0.15% degradation per 1k hours)")
for i in range(0,Life_hours,10000): #step by 1,000 hrs
    plt.plot(iv_plotting[i][0],iv_plotting_1a[i][1]) #first hour, current, first hour voltage

from matplotlib import pyplot as plt
plt.plot(temp_degraded_voltage[0:2000])
plt.xlabel("Time (hour)")
plt.ylabel("Operating voltage (Vop)")
plt.title('Mode 1A Jop of 1.7')
plt.show()

"""# 4.) Mode 1B - Any Jop in range Constantly"""

# ##############################################
## USE THIS VERSION FOR 1B!! FEBRUARY 7, 2022 - FOR HANDLING TERMINAL VOLTAGE
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# 
import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("fig4.csv","w")
print("Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []

# runs Mode 1A for all datasets 
# for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
# for mean in dfElPrice:     #for mean in df_array_dict:
#     print("Mean Price:", mean)
#     dfElPrice = df_array_dict[mean]

# Technical Variables 
Jop_rated = 1.7 # A/cm2
Vop_rated = 1.75292048 # Volts
Capacity = 1000  # conversion factor from kW to watts
Capacity_kW = 10000 #kW
Stack_cost_1kW = 473.92 #2020 USD 
M_BOP_1kW = 150.10 #2020 USD 
E_BOP_1kW = 130.48 #2020 USD 
CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

# changing capex with current density
Electronics_percentage = 0.26 # cost increase
# for electrical balance of plant and phase separator and dryers
CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

#set_trace()

Jop_ = 0.1
Fit_1 = 1.44926681  #C
Fit_2 = 2.71725674 #A
Fit_3 = 0.06970714 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
#Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
#C + A * (1 - math.exp(-k * value)) for value in x

iv_plotting_dict_1b = {}

while Jop_ <= 0.3: # 1.7 A/cm2 is only available Jop for Mode 1A
    print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
    Jop = [Jop_] #ONLY 1.7
    # Jop as array
    Jop = np.array(Jop)

    # Corresponding voltages for Jops

    Vop = [Y(Jop[0])] #only 1.7
    # Vop as array
    Vop = np.array(Vop)

    # Vop_copy is a copy of Vop upon which degradation is
    # applied.  So we have access to origin Vop if needed
    Vop_copy = Vop.copy()

    #set_trace()

    #for iV curve plot
    iv_plotting_1b = []
    i_plot = np.linspace(0, 6, num=61)
    i_plot = np.round(i_plot, 1) #rounding needs to be 1
    v_plot = Y_vector(i_plot)
    iv_plotting_1b.append(v_plot)
    
    
    
    #set_trace()

#     i_plot = [0]
#     temp_y = 0
#     for i in range(60):
#         temp_y += 0.10
#         i_plot.append(round(temp_y,2))
#     v_plot = [Y(x) for x in i_plot]
#     iv_plotting.append([i_plot,v_plot])

    #while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
#     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
#     Vop_ = Y(Jop_) 

    n_mol = 2  # constant for H2
    F = 96485  # Faraday's constant
    V_threshold = 2.9  # voltage at which current removed from options

    N_life = 10  # life of electrolyzer

    DR = 0.10  # discount rate

    # vary A/cm2 in 0.1 increments 0 to 6.0 
#     Jop = [Jop_] 
#     print("Jop:",Jop[0])

#     Vop = [Vop_] #1.79
#     print("Vop:",Vop[0])

#     PReq = []  # kW required per hour
#     for i in range(len(Jop)):  
#         if Jop[i] != 0:
#             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
#         else:
#             PReq.append(0)

    # degrade voltage
    Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
    # every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

    # prevents Jop[i] and Vop[i] from being modified
#     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

#         if Jop[i] != 0:
#             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
#         else:
#             PReq[i] = 0
#         return PReq[i]

    #12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
    M_CAPEX = []  # varying the CAPEX_Electronics with Jop
    for k in range(len(Jop)):
        if Jop[k] > 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop[k]*Vop[k]/1000
            Installation_Factor = 1.19 #Installed CAPEX 
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        elif Jop[k] > 0 and Jop[k] <= 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
            Installation_Factor = 1.19
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        else:
            M_CAPEX.append(0)  

    # array
    M_CAPEX = np.array(M_CAPEX)

    M_OM = [x*0.05 for x in M_CAPEX] 

    #array
    M_OM = np.array(M_OM)

    # Rate of fuel production in kg every hour of year 1
    M_kgh2 = []
    for k in range(len(Jop)):
        if Jop[k] != 0:
            M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
        else:
            M_kgh2.append(0)  # 0 kg produced when Jop=0

    # array
    M_kg2 = np.array(M_kgh2)

    #12.28.21 - LCOH column names list
    LCOH_column_names = []
    LCOH_2D_data = [] #box

    for i in range(len(Jop)):
        LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

    for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
        LCOH_column_names.append(name)

    break_point = None #to determine hour at which electrolyzer dies
    hour = 0
    for price in dfElPrice:
    #     for price in dfElPrice:  
        # Preq is a numpy array
        hour+=1     
        #Make EC NAN if terminal voltage is reached - Feb 7, 2022
        # if Vop is > Vthreshold make EC NAN
        if Vop_copy >= V_threshold:
            if break_point == None:
                break_point = hour 
            #determine when EOL reached with hour variable
            EC = [np.nan for i in Jop] #must be an array
            EC = np.array(EC)
        else:
            EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage #EC is an array
    
    
#     for price in dfElPrice:  
#         # Preq is a numpy array
#         EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage

        #set_trace()

        # if EC is NAN then make the corresponding elements NAN
        # in M_kg2, M_CAPEX and M_OM

        M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
#         M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
        M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

        #set_trace()

        # array
        marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

        #set_trace()

        #marginal LCOH per Jop
        # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
        #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
        #LCOH_hourly_data.append(marginal_LCOH_value)

#                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
#         for df_LCOH in df_LCOH_total_list:  

        #minimum LCOH per hour - ignore nan values
        margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
        margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
        #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

        #set_trace()

        #Energy charge minimum
        EC_min = EC[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

        #Jop that minimizes marginal LCOH  and corresponding Vop
        Jop_min = Jop[margLCOH_min_index]
        Vop_copy_min = Vop_copy[margLCOH_min_index]
        #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

        #kg associated with min LCOH
        M_kgh2_min = M_kgh2[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

        #CAP associated with min LCOH
        M_CAP_min = M_CAPEX[margLCOH_min_index]

        #OM associated with min LCOH
        M_OM_min = M_OM[margLCOH_min_index]

#         set_trace()

        # calculate degradation amount on the Vop 
        # that minimizes margLCOH
        Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

        # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
        # the same amount 
        Vop_copy += Degradation_Amount

        Degradation_List.append(Degradation_Amount) #collect degradation amounts
#         set_trace()

        #add hourly degradation to V_plot for plotting
        #v_plot += Degradation_Amount
        #v_plot = [x + Degradation_Amount for x in v_plot]
        iv_plotting_1b.append(iv_plotting_1b[-1] + Degradation_Amount)

#         set_trace()

#                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
#                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
#                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
#                               "OptimalJop","m_kgmin"]
        data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                            margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
        LCOH_2D_data.append(data_row)

#         set_trace()


# #################################################################
# ###################################################################
#     set_trace()
    #all 10 years
    df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
    CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
#     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
#     set_trace()

#split into 10 years for the DCFA
    df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
    start = 0
    stop = Life_1year
    for i in range(10):
        df_LCOH_temp = df_LCOH.iloc[start:stop]
        df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
        start = stop
        stop = (i + 2) * Life_1year # cycles though each year

    for df in df_LCOH_total_list:
        df.index = range(Life_1year)
#     set_trace()

       #12.28.21 - sum kg and EC for 10 years in 1 year increments
    OptimalEC_List_DCFA = []
    OptimalKG_List_DCFA = []
    OptimalOM_List_DCFA = []
    
    for df_LCOH in df_LCOH_total_list:
        OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
        OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
        OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))

    #sum one year of hourly OM associated with minimum marginal LCOH   
#         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

#     set_trace()     

    df_DCFA = pd.DataFrame(data={})
    df_DCFA["Year"] = list(range(0, 11))

    df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

    df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]
    
    OptimalOM_List_DCFA.insert(0, 0)
    df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalEC_List_DCFA.insert(0, 0)
    df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalKG_List_DCFA.insert(0, 0)
    df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

#         # Calculate LCOH

    PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

    PV_KG = df_DCFA["PV_KG"].sum()
    Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

#         # Contribution analysis

    CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

    OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

    EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

    df_DCFA["PV_KG"].sum()

    OptimalJop_mean = []
    for year in range(10):
        OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
    Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
    Year1_Jop = OptimalJop_mean[0]
    Year10_Jop = OptimalJop_mean[9]

#         # write to csv
    print(Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, Total_CAPEX, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
    print("UNINST CAPperKW:", CAPEX_per_1kW)
    print("INST CAPEX:", Total_CAPEX)
    print("PV_EC:", df_DCFA["PV_EC"].sum())
    print("PV_KG:", PV_KG)
    print("PV_OM:", df_DCFA["PV_OM"].sum())
    print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
    
    iv_plotting_dict_1b[str(round(Jop_,2))] = iv_plotting_1b
    
    Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("fig4.csv")
df_csv

iv_plotting_dict_1b.keys()

BOL_1b_0_1_Jop = iv_plotting_dict_1b['0.1'][0]
EOL_1b_0_1_Jop = iv_plotting_dict_1b['0.1'][-1]

print(BOL_1b_0_1_Jop)
print(EOL_1b_0_1_Jop)

print("break point hour:", (break_point-1))
EOL = ((break_point-1)/Life_1year)+1
EOL

iv_plotting_1b[break_point-1][17]

"""# 5.) Mode 2A - Jop of 0.1 OR 1.7"""

# ##############################################
# USE THIS VERSION - FOR MODE 2A - Feb 7, 2022 - 0.1 OR 1.7 A/cm2
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 
import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode2a.csv","w")
print("Mean Price","Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []

# runs Mode 1A for all datasets 
# for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
# # for mean in ["0.0"]:     #for mean in df_array_dict:
#     print("Mean Price:", mean)
#     dfElPrice = df_array_dict[mean]

# Technical Variables 
Jop_rated = 1.7 # A/cm2
Vop_rated = 1.75292048 # Volts
Capacity = 1000  # conversion factor from kW to watts
Capacity_kW = 10000 #kW
Stack_cost_1kW = 473.92 #2020 USD 
M_BOP_1kW = 150.10 #2020 USD 
E_BOP_1kW = 130.48 #2020 USD 
CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

# changing capex with current density
Electronics_percentage = 0.26 # cost increase
# for electrical balance of plant and phase separator and dryers
CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

#set_trace()

#     Jop_ = 0.1
Fit_1 = 1.44926681  #C
Fit_2 = 2.71725674 #A
Fit_3 = 0.06970714 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
#Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
#C + A * (1 - math.exp(-k * value)) for value in x

Jop = [0,0.1,1.7] 
# Jop as array
Jop = np.array(Jop)

# Corresponding voltages for Jops

Vop = [Y(Jop[0]), Y(Jop[1]), Y(Jop[2])]
# Vop as array
Vop = np.array(Vop)

# Vop_copy is a copy of Vop upon which degradation is
# applied.  So we have access to origin Vop if needed
Vop_copy = Vop.copy()

#set_trace()

#for iV curve plot
iv_plotting_2a = []
i_plot = np.linspace(0, 6, num=61)
i_plot = np.round(i_plot, 1) #rounding needs to be 1
v_plot = Y_vector(i_plot)
iv_plotting_2a.append(v_plot)

#set_trace()

#     i_plot = [0]
#     temp_y = 0
#     for i in range(60):
#         temp_y += 0.10
#         i_plot.append(round(temp_y,2))
#     v_plot = [Y(x) for x in i_plot]
#     iv_plotting.append([i_plot,v_plot])

#while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
#     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
#     Vop_ = Y(Jop_) 

n_mol = 2  # constant for H2
F = 96485  # Faraday's constant
V_threshold = 2.9  # voltage at which current removed from options

N_life = 10  # life of electrolyzer

DR = 0.10  # discount rate

# vary A/cm2 in 0.1 increments 0 to 6.0 
#     Jop = [Jop_] 
#     print("Jop:",Jop[0])

#     Vop = [Vop_] #1.79
#     print("Vop:",Vop[0])

#     PReq = []  # kW required per hour
#     for i in range(len(Jop)):  
#         if Jop[i] != 0:
#             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
#         else:
#             PReq.append(0)

# degrade voltage
Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
# every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

# prevents Jop[i] and Vop[i] from being modified
#     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

#         if Jop[i] != 0:
#             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
#         else:
#             PReq[i] = 0
#         return PReq[i]

#12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
M_CAPEX = []  # varying the CAPEX_Electronics with Jop
for k in range(len(Jop)):
    if Jop[k] > 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop[k]*Vop[k]/1000
        Installation_Factor = 1.19 #Installed CAPEX 
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    elif Jop[k] > 0 and Jop[k] <= 1.7:
        CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
        Installation_Factor = 1.19
        Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
        M_CAPEX.append(Total_CAPEX/Life_hours) 
    else:
        M_CAPEX.append(0)  

# array
M_CAPEX = np.array(M_CAPEX)

M_OM = [x*0.05 for x in M_CAPEX] 

#array
M_OM = np.array(M_OM)

# Rate of fuel production in kg every hour of year 1
M_kgh2 = []
for k in range(len(Jop)):
    if Jop[k] != 0:
        M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
    else:
        M_kgh2.append(0)  # 0 kg produced when Jop=0

# array
M_kg2 = np.array(M_kgh2)

#12.28.21 - LCOH column names list
LCOH_column_names = []
LCOH_2D_data = [] #box

for i in range(len(Jop)):
    LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

for i in range(len(Jop)):
    LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
    LCOH_column_names.append(name)

break_point_0_0 = None #to determine hour at which electrolyzer dies
break_point_0_1 = None
break_point_1_7 = None
hour = 0
for price in dfElPrice:
#     for price in dfElPrice:  
    # Preq is a numpy array
    hour+=1     
    #Make EC NAN if terminal voltage is reached - Feb 7, 2022
    # if Vop is > Vthreshold make EC NAN
#     if Vop_copy >= V_threshold: #in Mode 2A Vop_copy is an array
#         if break_point == None:
#             break_point = hour 
        #determine when EOL reached with hour variable
#             EC = [np.nan for i in Jop] #must be an array and work for all Jop options - Feb 7, 2022
    condition = Vop_copy >= V_threshold
    #check if break point reached for each Jop
    if condition[0] == True:
        if break_point_0_0 == None:
            break_point_0_0 = hour 
    if condition[1] == True:
        if break_point_0_1 == None:
            break_point_0_1 = hour 
    if condition[2] == True:
        if break_point_1_7 == None:
            break_point_1_7 = hour 
            
    EC = np.where(condition, np.nan, price * (A * Jop * Vop_copy) / 1000) #makes EC nAn if >=threshold
#             EC = np.array(EC)
#         else:
#             EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage #EC is an array

#     set_trace()

    # if EC is NAN then make the corresponding elements NAN
    # in M_kg2, M_CAPEX and M_OM

    M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
#         M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
    M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

    #set_trace()

    # array
    marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

    #set_trace()

    #marginal LCOH per Jop
    # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
    #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
    #LCOH_hourly_data.append(marginal_LCOH_value)

#                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
#         for df_LCOH in df_LCOH_total_list:  

    #minimum LCOH per hour - ignore nan values - dealing with NaN
    try:
        margLCOH_min = np.nanmin(marginal_LCOH_value) #np.nanmin
        margLCOH_min_index = np.nanargmin(marginal_LCOH_value) # np.nanargmin
    except ValueError:
        margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
        margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin

    #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

    #set_trace()

    #Energy charge minimum
    EC_min = EC[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

    #Jop that minimizes marginal LCOH  and corresponding Vop
    Jop_min = Jop[margLCOH_min_index]
    if Jop_min == 0: Jop_min = np.nan #boundary condition to avoid zero as optimal Jop
    Vop_copy_min = Vop_copy[margLCOH_min_index]
    #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

    #kg associated with min LCOH
    M_kgh2_min = M_kgh2[margLCOH_min_index]
    #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

    #CAP associated with min LCOH
    M_CAP_min = M_CAPEX[margLCOH_min_index]

    #OM associated with min LCOH
    M_OM_min = M_OM[margLCOH_min_index]

#     set_trace()

    # calculate degradation amount on the Vop 
    # that minimizes margLCOH
    Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

    # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
    # the same amount 
    Vop_copy += Degradation_Amount

    Degradation_List.append(Degradation_Amount) #collect degradation amounts
#         set_trace()

    #add hourly degradation to V_plot for plotting
    #v_plot += Degradation_Amount
    #v_plot = [x + Degradation_Amount for x in v_plot]
    iv_plotting_2a.append(iv_plotting_2a[-1] + Degradation_Amount)

#         set_trace()

#                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
#                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
#                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
#                               "OptimalJop","m_kgmin"]
    data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                        margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
    LCOH_2D_data.append(data_row)

#         set_trace()


# #################################################################
# ###################################################################
#     set_trace()
#all 10 years
df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
#     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
#     set_trace()

#split into 10 years for the DCFA
df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
start = 0
stop = Life_1year
for i in range(10):
    df_LCOH_temp = df_LCOH.iloc[start:stop]
    df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
    start = stop
    stop = (i + 2) * Life_1year # cycles though each year

for df in df_LCOH_total_list:
    df.index = range(Life_1year)
#     set_trace()

   #12.28.21 - sum kg and EC for 10 years in 1 year increments
OptimalEC_List_DCFA = []
OptimalKG_List_DCFA = []
OptimalOM_List_DCFA = []
for df_LCOH in df_LCOH_total_list:
    OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
    OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
    OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))

#sum one year of hourly OM associated with minimum marginal LCOH   
#         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

#     set_trace()     

df_DCFA = pd.DataFrame(data={})
df_DCFA["Year"] = list(range(0, 11))

df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

OptimalOM_List_DCFA.insert(0, 0)
df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

OptimalEC_List_DCFA.insert(0, 0)
df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

OptimalKG_List_DCFA.insert(0, 0)
df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

#         # Calculate LCOH

PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

PV_KG = df_DCFA["PV_KG"].sum()
Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

#         # Contribution analysis

CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

df_DCFA["PV_KG"].sum()

OptimalJop_mean = []
for year in range(10):
    OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
Year1_Jop = OptimalJop_mean[0]
Year10_Jop = OptimalJop_mean[9]

#         # write to csv
print(mean, Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, Total_CAPEX, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
print("UNINST CAPperKW:", CAPEX_per_1kW)
print("INST CAPEX:", Total_CAPEX)
print("PV_EC:", df_DCFA["PV_EC"].sum())
print("PV_KG:", PV_KG)
print("PV_OM:", df_DCFA["PV_OM"].sum())
print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
#Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode2a.csv")
df_csv

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook 
for hour in range(0,Life_hours,8759): 
    plt.plot(i_plot,iv_plotting_2a[hour])

"""# 6.) Mode 2B - Jop of 0.1 OR any between 0.1 and 6.0"""

# ##############################################
# MODE 2B - JAN 28 - USE THIS VERSION - capex correction - note this does not do terminal voltage
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
#1.16.22 - MODE 2B - 0.1 OR ANY ONE JOP BETWEEN 0.1 AND 6.0
# 
import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode2b.csv","w")
print("Mean Price","Second Current","Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

Degradation_List = []
iv_plotting_mean_dict_2b = {}

#create possible second currents
second_current_list = []
second_current_start = 0.0
for i in range(61):  
    second_current_list.append(second_current_start)
    second_current_start += 0.1
    
# runs Mode 1A for all datasets 
for mean in ["0.0","0.01"]:     #for mean in df_array_dict:
# for mean in ["0.0"]:     #for mean in df_array_dict:
    print("Mean Price:", mean)
    dfElPrice = df_array_dict[mean]

    # Technical Variables 
    Jop_rated = 1.7 # A/cm2
    Vop_rated = 1.75292048 # Volts
    Capacity = 1000  # conversion factor from kW to watts
    Capacity_kW = 10000 #kW
    Stack_cost_1kW = 473.92 #2020 USD 
    M_BOP_1kW = 150.10 #2020 USD 
    E_BOP_1kW = 130.48 #2020 USD 
    CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5
    
    # changing capex with current density
    Electronics_percentage = 0.26 # cost increase
    # for electrical balance of plant and phase separator and dryers
    CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
    CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
    A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
    CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW
    
    #set_trace()
    
#     Jop_ = 0.1
    Fit_1 = 1.44926681  #C
    Fit_2 = 2.71725674 #A
    Fit_3 = 0.06970714 #K
    Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
    Y_vector = np.vectorize(Y)
    #Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
    #C + A * (1 - math.exp(-k * value)) for value in x
    
    iv_plotting_dict_2b = {}
    for second_current in second_current_list[59:60]: #start from 0.1 A/cm2  
        print("second current:", second_current)
        Jop = [0,0.1,second_current] 
        # Jop as array
        Jop = np.array(Jop)

        # Corresponding voltages for Jops

        Vop = [Y(Jop[0]), Y(Jop[1]), Y(Jop[2])]
        # Vop as array
        Vop = np.array(Vop)

        # Vop_copy is a copy of Vop upon which degradation is
        # applied.  So we have access to origin Vop if needed
        Vop_copy = Vop.copy()

        #set_trace()

        #for iV curve plot
        iv_plotting_2b = []
        i_plot = np.linspace(0, 6, num=61) #must be 61
        i_plot = np.round(i_plot, 1) #must be 1 decimal place
        v_plot = Y_vector(i_plot)
        iv_plotting_2b.append(v_plot)

        #set_trace()

    #     i_plot = [0]
    #     temp_y = 0
    #     for i in range(60):
    #         temp_y += 0.10
    #         i_plot.append(round(temp_y,2))
    #     v_plot = [Y(x) for x in i_plot]
    #     iv_plotting.append([i_plot,v_plot])

        #while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
    #     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
    #     Vop_ = Y(Jop_) 

        n_mol = 2  # constant for H2
        F = 96485  # Faraday's constant
        V_threshold = 2.9  # voltage at which current removed from options

        N_life = 10  # life of electrolyzer

        DR = 0.10  # discount rate

        # vary A/cm2 in 0.1 increments 0 to 6.0 
    #     Jop = [Jop_] 
    #     print("Jop:",Jop[0])

    #     Vop = [Vop_] #1.79
    #     print("Vop:",Vop[0])

    #     PReq = []  # kW required per hour
    #     for i in range(len(Jop)):  
    #         if Jop[i] != 0:
    #             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
    #         else:
    #             PReq.append(0)

        # degrade voltage
        Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
        # every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

        # prevents Jop[i] and Vop[i] from being modified
    #     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

    #         if Jop[i] != 0:
    #             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
    #         else:
    #             PReq[i] = 0
    #         return PReq[i]

        #12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
        M_CAPEX = []  # varying the CAPEX_Electronics with Jop
        for k in range(len(Jop)):
            if second_current > 1.7:
                CAPEX_Electronics_Total =  CAPEX_Electronics*A*second_current*Vop[2]/1000
                Installation_Factor = 1.19 #Installed CAPEX 
                Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
                M_CAPEX.append(Total_CAPEX/Life_hours) 
            elif second_current > 0 and second_current <= 1.7:
                CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
                Installation_Factor = 1.19
                Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
                M_CAPEX.append(Total_CAPEX/Life_hours) 
            else:
                M_CAPEX.append(0)  

        # array
        M_CAPEX = np.array(M_CAPEX)

        M_OM = [x*0.05 for x in M_CAPEX] 

        #array
        M_OM = np.array(M_OM)

        # Rate of fuel production in kg every hour of year 1
        M_kgh2 = []
        for k in range(len(Jop)):
            if Jop[k] != 0:
                M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
            else:
                M_kgh2.append(0)  # 0 kg produced when Jop=0

        # array
        M_kg2 = np.array(M_kgh2)

        #12.28.21 - LCOH column names list
        LCOH_column_names = []
        LCOH_2D_data = [] #box

        for i in range(len(Jop)):
            LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

        for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
            LCOH_column_names.append(name)

        for price in dfElPrice:  
            # Preq is a numpy array
            EC = price * (A * Jop * Vop_copy) / 1000 #vop_copy is degraded voltage

            #set_trace()

            # if EC is NAN then make the corresponding elements NAN
            # in M_kg2, M_CAPEX and M_OM

    #         M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
    #         M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
    #         M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

            #set_trace()

            # array
            marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

            #set_trace()

            #marginal LCOH per Jop
            # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
            #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
            #LCOH_hourly_data.append(marginal_LCOH_value)

    #                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
    #         for df_LCOH in df_LCOH_total_list:  

            #minimum LCOH per hour - ignore nan values
            margLCOH_min = np.nanmin(marginal_LCOH_value)
            margLCOH_min_index = np.nanargmin(marginal_LCOH_value)
            #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

            #set_trace()

            #Energy charge minimum
            EC_min = EC[margLCOH_min_index]
            #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

            #Jop that minimizes marginal LCOH  and corresponding Vop
            Jop_min = Jop[margLCOH_min_index]
            Vop_copy_min = Vop_copy[margLCOH_min_index]
            #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

            #kg associated with min LCOH
            M_kgh2_min = M_kgh2[margLCOH_min_index]
            #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

            #CAP associated with min LCOH
            M_CAP_min = M_CAPEX[margLCOH_min_index]

            #OM associated with min LCOH
            M_OM_min = M_OM[margLCOH_min_index]

    #         set_trace()

            # calculate degradation amount on the Vop 
            # that minimizes margLCOH
            Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

            # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
            # the same amount 
            Vop_copy += Degradation_Amount

            Degradation_List.append(Degradation_Amount) #collect degradation amounts
    #         set_trace()

            #add hourly degradation to V_plot for plotting
            #v_plot += Degradation_Amount
            #v_plot = [x + Degradation_Amount for x in v_plot]
            iv_plotting_2b.append(iv_plotting_2b[-1] + Degradation_Amount)

    #         set_trace()

    #                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
    #                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
    #                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
    #                               "OptimalJop","m_kgmin"]
            data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                                margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
            LCOH_2D_data.append(data_row)

    #         set_trace()


    # #################################################################
    # ###################################################################
    #     set_trace()
        #all 10 years
        df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
        CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
    #     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
    #     set_trace()

    #split into 10 years for the DCFA
        df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
        start = 0
        stop = Life_1year
        for i in range(10):
            df_LCOH_temp = df_LCOH.iloc[start:stop]
            df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
            start = stop
            stop = (i + 2) * Life_1year # cycles though each year

        for df in df_LCOH_total_list:
            df.index = range(Life_1year)
    #     set_trace()

           #12.28.21 - sum kg and EC for 10 years in 1 year increments
        OptimalEC_List_DCFA = []
        OptimalKG_List_DCFA = []
        for df_LCOH in df_LCOH_total_list:
            OptimalEC_List_DCFA.append(df_LCOH["m_ECmin"].sum())
            OptimalKG_List_DCFA.append(df_LCOH["m_kgmin"].sum())
            OM_Total_1st = (df_LCOH["m_OMmin"].sum()) #does the same thing as OM_Total_1st

        #sum one year of hourly OM associated with minimum marginal LCOH   
    #         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

    #     set_trace()     

        df_DCFA = pd.DataFrame(data={})
        df_DCFA["Year"] = list(range(0, 11))

        df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

        df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

        df_DCFA["PV_OM"] = [0 if i == 0 else (OM_Total_1st * 10 * df_DCFA["PWF"][i]) for i in range(11)]

        OptimalEC_List_DCFA.insert(0, 0)
        df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

        OptimalKG_List_DCFA.insert(0, 0)
        df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    #         # Calculate LCOH

        PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

        PV_KG = df_DCFA["PV_KG"].sum()
        Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

    #         # Contribution analysis

        CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

        OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

        EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

        df_DCFA["PV_KG"].sum()

        OptimalJop_mean = []
        for year in range(10):
            OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
        Average_Jop_10yr = sum(OptimalJop_mean) / len(OptimalJop_mean) 
        Year1_Jop = OptimalJop_mean[0]
        Year10_Jop = OptimalJop_mean[9]

    #         # write to csv
        print(mean, second_current, Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, CAP_Total, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
        print("UNINST CAPperKW:", CAPEX_per_1kW)
        print("INST CAPEX:", CAP_Total)
        print("PV_EC:", df_DCFA["PV_EC"].sum())
        print("PV_KG:", PV_KG)
        print("PV_OM:", df_DCFA["PV_OM"].sum())
        print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
        
        iv_plotting_dict_2b[str(round(second_current,2))] = iv_plotting_2b
        
    iv_plotting_mean_dict_2b[mean] = iv_plotting_dict_2b
    
    #Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode2b.csv")
df_csv

iv_plotting_mean_dict_2b.keys()

iv_plotting_mean_dict_2b['0.0']['5.9']

"""# 6.) Mode 3 - any Jop every hour"""

# ##############################################
# ## USE THIS VERSION FOR 3!! February 7, 2022 - handling terminal voltage and CAPEX correction
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

# 
import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode3.csv","w")
print("Max Jop","Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

iv_plotting_mean_dict_3 = {}
Degradation_List = []

#create possible currents
second_current_list = []
second_current_start = 0.0
for i in range(61):  
    second_current_list.append(second_current_start)
    second_current_start += 0.1
    
# runs Mode 1A for all datasets 
# for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
# # for mean in ["0.0"]:     #for mean in df_array_dict:
#     print("Mean Price:", mean)
#     dfElPrice = df_array_dict[mean]

# Technical Variables 
Jop_rated = 1.7 # A/cm2
Vop_rated = 1.75292048 # Volts
Capacity = 1000  # conversion factor from kW to watts
Capacity_kW = 10000 #kW
Stack_cost_1kW = 473.92 #2020 USD 
M_BOP_1kW = 150.10 #2020 USD 
E_BOP_1kW = 130.48 #2020 USD 
CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

# changing capex with current density
Electronics_percentage = 0.26 # cost increase
# for electrical balance of plant and phase separator and dryers
CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

#set_trace()

#     Jop_ = 0.1
Fit_1 = 1.44926681  #C
Fit_2 = 2.71725674 #A
Fit_3 = 0.06970714 #K
Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
#Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
#C + A * (1 - math.exp(-k * value)) for value in x

break_point_dictionary = {} #for all options of CAPEX
iv_plotting_dict_3 = {}
for Jop_range_stop in range(61,1,-1): #2.26.21 - #middle value is last value, vary range of max Jop so CAPEX varies with range
    Jop = []
    Jop_start = 0.0
    for i in range(Jop_range_stop):  # 10.9.20 - increase to 9A/cm2
        Jop.append(Jop_start)
        Jop_start += 0.1
    print("Max_Jop:", Jop[-1])

#     for second_current in second_current_list[20:21]: #start from 0.1 A/cm2  
#         print("second current:", second_current)
#         Jop = [0,0.1,second_current] 
#         # Jop as array
    Jop = np.array(Jop)

    # Corresponding voltages for Jops

    Vop = [Y(current) for current in Jop]
    # Vop as array
    Vop = np.array(Vop)

    # Vop_copy is a copy of Vop upon which degradation is
    # applied.  So we have access to origin Vop if needed
    Vop_copy = Vop.copy()

    #set_trace()

    #for iV curve plot
    iv_plotting_3 = []
    i_plot = np.linspace(0, 6, num=61) #must be 61
    i_plot = np.round(i_plot, 1) #must be 1 decimal place
    v_plot = Y_vector(i_plot)
    iv_plotting_3.append(v_plot)

    #set_trace()

#     i_plot = [0]
#     temp_y = 0
#     for i in range(60):
#         temp_y += 0.10
#         i_plot.append(round(temp_y,2))
#     v_plot = [Y(x) for x in i_plot]
#     iv_plotting.append([i_plot,v_plot])

    #while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
#     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
#     Vop_ = Y(Jop_) 

    n_mol = 2  # constant for H2
    F = 96485  # Faraday's constant
    V_threshold = 2.9  # voltage at which current removed from options

    N_life = 10  # life of electrolyzer

    DR = 0.10  # discount rate

    # vary A/cm2 in 0.1 increments 0 to 6.0 
#     Jop = [Jop_] 
#     print("Jop:",Jop[0])

#     Vop = [Vop_] #1.79
#     print("Vop:",Vop[0])

#     PReq = []  # kW required per hour
#     for i in range(len(Jop)):  
#         if Jop[i] != 0:
#             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
#         else:
#             PReq.append(0)

    # degrade voltage
    Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
    # every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

    # prevents Jop[i] and Vop[i] from being modified
#     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

#         if Jop[i] != 0:
#             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
#         else:
#             PReq[i] = 0
#         return PReq[i]

    #12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
    M_CAPEX = []  # varying the CAPEX_Electronics with Jop
    for k in range(len(Jop)):
        if Jop[-1] > 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A* Jop[-1]*Vop[-1]/1000
            Installation_Factor = 1.19 #Installed CAPEX 
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        elif Jop[-1] > 0 and Jop[-1] <= 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
            Installation_Factor = 1.19
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        else:
            M_CAPEX.append(0)  

    # array
    M_CAPEX = np.array(M_CAPEX)

    M_OM = [x*0.05 for x in M_CAPEX] 

    #array
    M_OM = np.array(M_OM)

    # Rate of fuel production in kg every hour of year 1
    M_kgh2 = []
    for k in range(len(Jop)):
        if Jop[k] != 0:
            M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
        else:
            M_kgh2.append(0)  # 0 kg produced when Jop=0

    # array
    M_kg2 = np.array(M_kgh2)

    #12.28.21 - LCOH column names list
    LCOH_column_names = []
    LCOH_2D_data = [] #box

    for i in range(len(Jop)):
        LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

    for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
        LCOH_column_names.append(name)

    hour = 0
    break_point_list = [None for item in Vop_copy]
    for price in dfElPrice:
        hour+=1     
#Make EC NAN if terminal voltage is reached - Feb 7, 2022
# if Vop is > Vthreshold make EC NAN
#     if Vop_copy >= V_threshold: #in Mode 2A Vop_copy is an array
#         if break_point == None:
#             break_point = hour 
    #determine when EOL reached with hour variable
#             EC = [np.nan for i in Jop] #must be an array and work for all Jop options - Feb 7, 2022
        condition = Vop_copy >= V_threshold
#check if break point reached for each Jop
        for i_cond in range(len(condition)):
            if condition[i_cond] == True:
                if break_point_list[i_cond] == None:
                    break_point_list[i_cond] = hour
    

#     if condition[1] == True:
#         if break_point_0_1 == None:
#             break_point_0_1 = hour 
#     if condition[2] == True:
#         if break_point_1_7 == None:
#             break_point_1_7 = hour 

        EC = np.where(condition, np.nan, price * (A * Jop * Vop_copy) / 1000) #makes EC nAn if >=threshold
#             EC = np.array(EC)
        # Preq is a numpy array


        #set_trace()

        # if EC is NAN then make the corresponding elements NAN
        # in M_kg2, M_CAPEX and M_OM

        M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
#         M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
        M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

        #set_trace()

        # array
        marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

        try:
            margLCOH_min = np.nanmin(marginal_LCOH_value) #np.nanmin
            margLCOH_min_index = np.nanargmin(marginal_LCOH_value) # np.nanargmin
        except ValueError:
            margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
            margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
        #set_trace()

        #marginal LCOH per Jop
        # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
        #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
        #LCOH_hourly_data.append(marginal_LCOH_value)

#                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
#         for df_LCOH in df_LCOH_total_list:  

        #minimum LCOH per hour - ignore nan values
        #margLCOH_min = np.nanmin(marginal_LCOH_value)
        #margLCOH_min_index = np.nanargmin(marginal_LCOH_value)
        #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

        #set_trace()

        #Energy charge minimum
        EC_min = EC[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

        #Jop that minimizes marginal LCOH  and corresponding Vop
        Jop_min = Jop[margLCOH_min_index]
        if Jop_min == 0: Jop_min = np.nan #boundary condition to avoid zero as optimal Jop
        Vop_copy_min = Vop_copy[margLCOH_min_index]
        #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

        #kg associated with min LCOH
        M_kgh2_min = M_kgh2[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

        #CAP associated with min LCOH
        M_CAP_min = M_CAPEX[margLCOH_min_index]

        #OM associated with min LCOH
        M_OM_min = M_OM[margLCOH_min_index]

#         set_trace()

        # calculate degradation amount on the Vop 
        # that minimizes margLCOH
        Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

        # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
        # the same amount 
        Vop_copy += Degradation_Amount

        Degradation_List.append(Degradation_Amount) #collect degradation amounts
#         set_trace()

        #add hourly degradation to V_plot for plotting
        #v_plot += Degradation_Amount
        #v_plot = [x + Degradation_Amount for x in v_plot]
        iv_plotting_3.append(iv_plotting_3[-1] + Degradation_Amount)

#         set_trace()

#                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
#                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
#                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
#                               "OptimalJop","m_kgmin"]
        data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                            margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
        LCOH_2D_data.append(data_row)
        
#         set_trace()

    break_point_dictionary[str(round(Jop[-1],2))] = break_point_list,Jop
# #################################################################
# ###################################################################
#     set_trace()
    #all 10 years
    df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
    CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
#     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
#     set_trace()

#split into 10 years for the DCFA
    df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
    start = 0
    stop = Life_1year
    for i in range(10):
        df_LCOH_temp = df_LCOH.iloc[start:stop]
        df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
        start = stop
        stop = (i + 2) * Life_1year # cycles though each year

    for df in df_LCOH_total_list:
        df.index = range(Life_1year)
#     set_trace()

       #12.28.21 - sum kg and EC for 10 years in 1 year increments

    OptimalEC_List_DCFA = []
    OptimalKG_List_DCFA = []
    OptimalOM_List_DCFA = []
    for df_LCOH in df_LCOH_total_list:
        OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
        OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
        OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))

#         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

#     set_trace()     

    df_DCFA = pd.DataFrame(data={})
    df_DCFA["Year"] = list(range(0, 11))

    df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

    df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

    OptimalOM_List_DCFA.insert(0, 0)
    df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalEC_List_DCFA.insert(0, 0)
    df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalKG_List_DCFA.insert(0, 0)
    df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

#         # Calculate LCOH

    PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

    PV_KG = df_DCFA["PV_KG"].sum()
    Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

#         # Contribution analysis

    CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

    OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

    EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

    df_DCFA["PV_KG"].sum()

    OptimalJop_mean = []
    for year in range(10):
        OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
    Average_Jop_10yr = np.nansum(OptimalJop_mean) / len(OptimalJop_mean) 
    Year1_Jop = OptimalJop_mean[0]
    Year10_Jop = OptimalJop_mean[9]

#         # write to csv
    print(Jop[-1], Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, CAP_Total, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
    print("UNINST CAPperKW:", CAPEX_per_1kW)
    print("INST CAPEX:", CAP_Total)
    print("PV_EC:", df_DCFA["PV_EC"].sum())
    print("PV_KG:", PV_KG)
    print("PV_OM:", df_DCFA["PV_OM"].sum())
    print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
    
    iv_plotting_dict_3[str(round(Jop[0]))] = iv_plotting_3     #Jop[0] corresponds to range stop value
#     iv_plotting_dict_3[str(Jop_range_stop)] = iv_plotting_3

# iv_plotting_mean_dict_3[mean] = iv_plotting_dict_3
    
    #Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode3.csv")
df_csv

# ##############################################
# ## USE THIS VERSION FOR 3!! February 7, 2022 - handling terminal voltage and CAPEX correction
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

# 
import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode3.csv","w")
print("Max Jop","Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", "Hourly Jop", file=f_file,sep=",")

iv_plotting_mean_dict_3 = {}
Degradation_List = []

#create possible currents
second_current_list = []
second_current_start = 0.0
for i in range(61):  
    second_current_list.append(second_current_start)
    second_current_start += 0.1
    
# runs Mode 1A for all datasets 
for mean in ["0.07"]:     #for mean in df_array_dict:
# for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:

# for mean in df_array_dict:
#     print("Mean Price:", mean)
#     dfElPrice = df_array_dict[mean]

    # Technical Variables 
    Jop_rated = 1.7 # A/cm2
    Vop_rated = 1.75292048 # Volts
    Capacity = 1000  # conversion factor from kW to watts
    Capacity_kW = 10000 #kW
    Stack_cost_1kW = 473.92 #2020 USD 
    M_BOP_1kW = 150.10 #2020 USD 
    E_BOP_1kW = 130.48 #2020 USD 
    CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

    # changing capex with current density
    Electronics_percentage = 0.26 # cost increase
    # for electrical balance of plant and phase separator and dryers
    CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
    CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
    A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
    CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

    #set_trace()

    #     Jop_ = 0.1
    Fit_1 = 1.44926681  #C
    Fit_2 = 2.71725674 #A
    Fit_3 = 0.06970714 #K
    Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
    Y_vector = np.vectorize(Y)
    #Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
    #C + A * (1 - math.exp(-k * value)) for value in x

    break_point_dictionary = {} #for all options of CAPEX
    iv_plotting_dict_3 = {}
    for Jop_range_stop in range(19,18,-1): #2.26.21 - #middle value is last value, vary range of max Jop so CAPEX varies with range
        Jop = []
        Jop_start = 0.0
        for i in range(Jop_range_stop):  # 10.9.20 - increase to 9A/cm2
            Jop.append(Jop_start)
            Jop_start += 0.1
        print("Max_Jop:", Jop[-1])

    #     for second_current in second_current_list[20:21]: #start from 0.1 A/cm2  
    #         print("second current:", second_current)
    #         Jop = [0,0.1,second_current] 
    #         # Jop as array
        Jop = np.array(Jop)

        # Corresponding voltages for Jops

        Vop = [Y(current) for current in Jop]
        # Vop as array
        Vop = np.array(Vop)

        # Vop_copy is a copy of Vop upon which degradation is
        # applied.  So we have access to origin Vop if needed
        Vop_copy = Vop.copy()

        #set_trace()

        #for iV curve plot
        iv_plotting_3 = []
        i_plot = np.linspace(0, 6, num=61) #must be 61
        i_plot = np.round(i_plot, 1) #must be 1 decimal place
        v_plot = Y_vector(i_plot)
        iv_plotting_3.append(v_plot)

        #set_trace()

    #     i_plot = [0]
    #     temp_y = 0
    #     for i in range(60):
    #         temp_y += 0.10
    #         i_plot.append(round(temp_y,2))
    #     v_plot = [Y(x) for x in i_plot]
    #     iv_plotting.append([i_plot,v_plot])

        #while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
    #     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
    #     Vop_ = Y(Jop_) 

        n_mol = 2  # constant for H2
        F = 96485  # Faraday's constant
        V_threshold = 2.9  # voltage at which current removed from options

        N_life = 10  # life of electrolyzer

        DR = 0.10  # discount rate

        # vary A/cm2 in 0.1 increments 0 to 6.0 
    #     Jop = [Jop_] 
    #     print("Jop:",Jop[0])

    #     Vop = [Vop_] #1.79
    #     print("Vop:",Vop[0])

    #     PReq = []  # kW required per hour
    #     for i in range(len(Jop)):  
    #         if Jop[i] != 0:
    #             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
    #         else:
    #             PReq.append(0)

        # degrade voltage
        Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
        # every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

        # prevents Jop[i] and Vop[i] from being modified
    #     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

    #         if Jop[i] != 0:
    #             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
    #         else:
    #             PReq[i] = 0
    #         return PReq[i]

        #12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
        M_CAPEX = []  # varying the CAPEX_Electronics with Jop
        for k in range(len(Jop)):
            if Jop[-1] > 1.7:
                CAPEX_Electronics_Total =  CAPEX_Electronics*A* Jop[-1]*Vop[-1]/1000
                Installation_Factor = 1.19 #Installed CAPEX 
                Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
                M_CAPEX.append(Total_CAPEX/Life_hours) 
            elif Jop[-1] > 0 and Jop[-1] <= 1.7:
                CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
                Installation_Factor = 1.19
                Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
                M_CAPEX.append(Total_CAPEX/Life_hours) 
            else:
                M_CAPEX.append(0)  

        # array
        M_CAPEX = np.array(M_CAPEX)

        M_OM = [x*0.05 for x in M_CAPEX] 

        #array
        M_OM = np.array(M_OM)

        # Rate of fuel production in kg every hour of year 1
        M_kgh2 = []
        for k in range(len(Jop)):
            if Jop[k] != 0:
                M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
            else:
                M_kgh2.append(0)  # 0 kg produced when Jop=0

        # array
        M_kg2 = np.array(M_kgh2)

        #12.28.21 - LCOH column names list
        LCOH_column_names = []
        LCOH_2D_data = [] #box

        for i in range(len(Jop)):
            LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

        for i in range(len(Jop)):
            LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

        for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
            LCOH_column_names.append(name)

        hour = 0
        break_point_list = [None for item in Vop_copy]
        for price in df_array_dict["0.07"]:
            hour+=1     
    #Make EC NAN if terminal voltage is reached - Feb 7, 2022
    # if Vop is > Vthreshold make EC NAN
    #     if Vop_copy >= V_threshold: #in Mode 2A Vop_copy is an array
    #         if break_point == None:
    #             break_point = hour 
        #determine when EOL reached with hour variable
    #             EC = [np.nan for i in Jop] #must be an array and work for all Jop options - Feb 7, 2022
            condition = Vop_copy >= V_threshold
    #check if break point reached for each Jop
            for i_cond in range(len(condition)):
                if condition[i_cond] == True:
                    if break_point_list[i_cond] == None:
                        break_point_list[i_cond] = hour


    #     if condition[1] == True:
    #         if break_point_0_1 == None:
    #             break_point_0_1 = hour 
    #     if condition[2] == True:
    #         if break_point_1_7 == None:
    #             break_point_1_7 = hour 

            EC = np.where(condition, np.nan, price * (A * Jop * Vop_copy) / 1000) #makes EC nAn if >=threshold
    #             EC = np.array(EC)
            # Preq is a numpy array


            #set_trace()

            # if EC is NAN then make the corresponding elements NAN
            # in M_kg2, M_CAPEX and M_OM

            M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
    #         M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
            M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

            #set_trace()

            # array
            marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

            try:
                margLCOH_min = np.nanmin(marginal_LCOH_value) #np.nanmin
                margLCOH_min_index = np.nanargmin(marginal_LCOH_value) # np.nanargmin
            except ValueError:
                margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
                margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
            #set_trace()

            #marginal LCOH per Jop
            # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
            #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
            #LCOH_hourly_data.append(marginal_LCOH_value)

    #                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
    #         for df_LCOH in df_LCOH_total_list:  

            #minimum LCOH per hour - ignore nan values
            #margLCOH_min = np.nanmin(marginal_LCOH_value)
            #margLCOH_min_index = np.nanargmin(marginal_LCOH_value)
            #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

            #set_trace()

            #Energy charge minimum
            EC_min = EC[margLCOH_min_index]
            #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

            #Jop that minimizes marginal LCOH  and corresponding Vop
            Jop_min = Jop[margLCOH_min_index]
            if Jop_min == 0: Jop_min = np.nan #boundary condition to avoid zero as optimal Jop
            Vop_copy_min = Vop_copy[margLCOH_min_index]
            #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

            #kg associated with min LCOH
            M_kgh2_min = M_kgh2[margLCOH_min_index]
            #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

            #CAP associated with min LCOH
            M_CAP_min = M_CAPEX[margLCOH_min_index]

            #OM associated with min LCOH
            M_OM_min = M_OM[margLCOH_min_index]

    #         set_trace()

            # calculate degradation amount on the Vop 
            # that minimizes margLCOH
            Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

            # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
            # the same amount 
            Vop_copy += Degradation_Amount

            Degradation_List.append(Degradation_Amount) #collect degradation amounts
    #         set_trace()

            #add hourly degradation to V_plot for plotting
            #v_plot += Degradation_Amount
            #v_plot = [x + Degradation_Amount for x in v_plot]
            iv_plotting_3.append(iv_plotting_3[-1] + Degradation_Amount)

    #         set_trace()

    #                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
    #                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
    #                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
    #                               "OptimalJop","m_kgmin"]
            data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                                margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
            LCOH_2D_data.append(data_row)

    #         set_trace()

        break_point_dictionary[str(round(Jop[-1],2))] = break_point_list,Jop
    # #################################################################
    # ###################################################################
    #     set_trace()
        #all 10 years
        df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
        CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
    #     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
    #     set_trace()

    #split into 10 years for the DCFA
        df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
        start = 0
        stop = Life_1year
        for i in range(10):
            df_LCOH_temp = df_LCOH.iloc[start:stop]
            df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
            start = stop
            stop = (i + 2) * Life_1year # cycles though each year

        for df in df_LCOH_total_list:
            df.index = range(Life_1year)
    #     set_trace()

           #12.28.21 - sum kg and EC for 10 years in 1 year increments

        OptimalEC_List_DCFA = []
        OptimalKG_List_DCFA = []
        OptimalOM_List_DCFA = []
        for df_LCOH in df_LCOH_total_list:
            OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
            OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
            OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))

    #         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

    #     set_trace()     

        df_DCFA = pd.DataFrame(data={})
        df_DCFA["Year"] = list(range(0, 11))

        df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

        df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

        OptimalOM_List_DCFA.insert(0, 0)
        df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

        OptimalEC_List_DCFA.insert(0, 0)
        df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

        OptimalKG_List_DCFA.insert(0, 0)
        df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    #         # Calculate LCOH

        PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

        PV_KG = df_DCFA["PV_KG"].sum()
        Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

    #         # Contribution analysis

        CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

        OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

        EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

        df_DCFA["PV_KG"].sum()

        OptimalJop_mean = []
        for year in range(10):
            OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
        Average_Jop_10yr = np.nansum(OptimalJop_mean) / len(OptimalJop_mean) 
        Year1_Jop = OptimalJop_mean[0]
        Year10_Jop = OptimalJop_mean[9]
        Hourly_Jop = (Year1_Jop + Year10_Jop) / 2

    #         # write to csv
        print(Jop[-1], Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, CAP_Total, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, Hourly_Jop, file=f_file,sep=",") 
        print("UNINST CAPperKW:", CAPEX_per_1kW)
        print("INST CAPEX:", CAP_Total)
        print("PV_EC:", df_DCFA["PV_EC"].sum())
        print("PV_KG:", PV_KG)
        print("PV_OM:", df_DCFA["PV_OM"].sum())
        print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)

        iv_plotting_dict_3[str(round(Jop[0]))] = iv_plotting_3     #Jop[0] corresponds to range stop value
    #     iv_plotting_dict_3[str(Jop_range_stop)] = iv_plotting_3

    # iv_plotting_mean_dict_3[mean] = iv_plotting_dict_3

        #Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode3.csv")
df_csv

# df_LCOH_total_list[year]["OptimalJop"]
OptimalJop_hourly = []
for year in range(10):
  OptimalJop_hourly.append(df_LCOH_total_list[year]["OptimalJop"])
# OptimalJop_hourly.mean()
OptimalJop_hourly

len(OptimalJop_hourly)

#save optimal Jop to csv
import csv
total = OptimalJop_hourly[0] + OptimalJop_hourly[1] + OptimalJop_hourly[2] + OptimalJop_hourly[3] + OptimalJop_hourly[4] + OptimalJop_hourly[5] + OptimalJop_hourly[6] + OptimalJop_hourly[7] + OptimalJop_hourly[8] + OptimalJop_hourly[9]
avg_10yr = total / len(OptimalJop_hourly)
optimalJop_dict = avg_10yr.to_dict()
df_optimalJop = pd.DataFrame({'1': optimalJop_dict})
df_optimalJop.to_csv('mean7_optimalJop.csv') #change name based on mean
# d = {'col1': [avg_10yr]}
# df_avg_10yr = pd.DataFrame(data=d)
# # df_avg_10yr.to_csv()
# df_avg_10yr_T = df_avg_10yr.transpose()
# # df_avg_10yr.to_csv('mean0_optimalJop.csv')
# df_avg_10yr_T

# ##############################################
# # high efficiency
# USE THIS VERSION FOR 3!! February 7, 2022 - handling terminal voltage and CAPEX correction
################################################
#XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

# 
import math  # for the exponential function
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from IPython.core.debugger import set_trace
#np.set_printoptions(precision=14)

# write results to csv
f_file = open("mode3.csv","w")
print("Max Jop","Average Jop 10 Yr", "LCOH","UNINST CAPperkW","INST CAPEX", "OPEX","OM","PV_Costs", "PV_KG", file=f_file,sep=",")

iv_plotting_mean_dict_3 = {}
Degradation_List = []

#create possible currents
second_current_list = []
second_current_start = 0.0
for i in range(61):  
    second_current_list.append(second_current_start)
    second_current_start += 0.1
    
# runs Mode 1A for all datasets 
# for mean in ["0.0","0.01", "0.02", "0.03", "0.04", "0.05", "0.06", "0.07"]:     #for mean in df_array_dict:
# # for mean in ["0.0"]:     #for mean in df_array_dict:
#     print("Mean Price:", mean)
#     dfElPrice = df_array_dict[mean]

# Technical Variables 
Jop_rated = 1.7 # A/cm2
Vop_rated = 1.7053156722491154 # Volts
Capacity = 1000  # conversion factor from kW to watts
Capacity_kW = 10000 #kW
Stack_cost_1kW = 473.92 #2020 USD 
M_BOP_1kW = 150.10 #2020 USD 
E_BOP_1kW = 130.48 #2020 USD 
CAPEX_per_1kW = Stack_cost_1kW + M_BOP_1kW + E_BOP_1kW #uninstalled cost = 754.5

# changing capex with current density
Electronics_percentage = 0.26 # cost increase
# for electrical balance of plant and phase separator and dryers
CAPEX_Electronics = Electronics_percentage*CAPEX_per_1kW
CAPEX_Rest = (1-Electronics_percentage)*CAPEX_per_1kW
A = (Capacity * Capacity_kW) / (Vop_rated * Jop_rated) #cm2 electrode area
CAPEX_Rest_Total = CAPEX_Rest*A*Jop_rated*Vop_rated/1000 #1000 converts to kW

#set_trace()

Fit_1 = 1.46767985  #C
Fit_2 = 0.46679002 #A
Fit_3 = 0.41852023 #K

Y = lambda X: (Fit_1 + Fit_2 * (1 - math.exp(-Fit_3 * X)))
Y_vector = np.vectorize(Y)
#Y = lambda X: ((0.156726387554 * X) + 1.47670128643691) #x is Jop_
#C + A * (1 - math.exp(-k * value)) for value in x

break_point_dictionary = {} #for all options of CAPEX
iv_plotting_dict_3 = {}
for Jop_range_stop in range(61,1,-1): #2.26.21 - #middle value is last value, vary range of max Jop so CAPEX varies with range
    Jop = []
    Jop_start = 0.0
    for i in range(Jop_range_stop):  # 10.9.20 - increase to 9A/cm2
        Jop.append(Jop_start)
        Jop_start += 0.1
    print("Max_Jop:", Jop[-1])

#     for second_current in second_current_list[20:21]: #start from 0.1 A/cm2  
#         print("second current:", second_current)
#         Jop = [0,0.1,second_current] 
#         # Jop as array
    Jop = np.array(Jop)

    # Corresponding voltages for Jops

    Vop = [Y(current) for current in Jop]
    # Vop as array
    Vop = np.array(Vop)

    # Vop_copy is a copy of Vop upon which degradation is
    # applied.  So we have access to origin Vop if needed
    Vop_copy = Vop.copy()

    #set_trace()

    #for iV curve plot
    iv_plotting_3 = []
    i_plot = np.linspace(0, 6, num=61) #must be 61
    i_plot = np.round(i_plot, 1) #must be 1 decimal place
    v_plot = Y_vector(i_plot)
    iv_plotting_3.append(v_plot)

    #set_trace()

#     i_plot = [0]
#     temp_y = 0
#     for i in range(60):
#         temp_y += 0.10
#         i_plot.append(round(temp_y,2))
#     v_plot = [Y(x) for x in i_plot]
#     iv_plotting.append([i_plot,v_plot])

    #while Jop_ <= 6.0: # 1.7 A/cm2 is only available Jop for Mode 1A
#     print("Jop_:", Jop_, "Jop_rated:", Jop_rated, "Vop_rated:", Vop_rated)
#     Vop_ = Y(Jop_) 

    n_mol = 2  # constant for H2
    F = 96485  # Faraday's constant
    V_threshold = 2.9  # voltage at which current removed from options

    N_life = 10  # life of electrolyzer

    DR = 0.10  # discount rate

    # vary A/cm2 in 0.1 increments 0 to 6.0 
#     Jop = [Jop_] 
#     print("Jop:",Jop[0])

#     Vop = [Vop_] #1.79
#     print("Vop:",Vop[0])

#     PReq = []  # kW required per hour
#     for i in range(len(Jop)):  
#         if Jop[i] != 0:
#             PReq.append((A * Jop[i] * Vop[i]) / 1000)  # kW
#         else:
#             PReq.append(0)

    # degrade voltage
    Degradation_Rate = 0.0015 / 1000  #0.15% per 1,000 hr https://www.fch.europa.eu/soa-and-targets
    # every hour 0.8% corresponds to 13.92 microvolts at 1.74v per Carmo

    # prevents Jop[i] and Vop[i] from being modified
#     def updatePReq(i, Jop_=Jop[i], Vop_=Vop[i]):  

#         if Jop[i] != 0:
#             PReq[i] = ((A * Jop_ * Vop_) / 1000)  # kW
#         else:
#             PReq[i] = 0
#         return PReq[i]

    #12.28.21 - M_CAP, M_OM and M_KG only need to be inside the while loop
    M_CAPEX = []  # varying the CAPEX_Electronics with Jop
    for k in range(len(Jop)):
        if Jop[-1] > 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A* Jop[-1]*Vop[-1]/1000
            Installation_Factor = 1.19 #Installed CAPEX 
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        elif Jop[-1] > 0 and Jop[-1] <= 1.7:
            CAPEX_Electronics_Total =  CAPEX_Electronics*A*Jop_rated*Vop_rated/1000
            Installation_Factor = 1.19
            Total_CAPEX = (CAPEX_Rest_Total + CAPEX_Electronics_Total)*Installation_Factor
            M_CAPEX.append(Total_CAPEX/Life_hours) 
        else:
            M_CAPEX.append(0)  

    # array
    M_CAPEX = np.array(M_CAPEX)

    M_OM = [x*0.05 for x in M_CAPEX] 

    #array
    M_OM = np.array(M_OM)

    # Rate of fuel production in kg every hour of year 1
    M_kgh2 = []
    for k in range(len(Jop)):
        if Jop[k] != 0:
            M_kgh2.append((Jop[k] * A) / (n_mol * F) * (0.002 * 3600))  
        else:
            M_kgh2.append(0)  # 0 kg produced when Jop=0

    # array
    M_kg2 = np.array(M_kgh2)

    #12.28.21 - LCOH column names list
    LCOH_column_names = []
    LCOH_2D_data = [] #box

    for i in range(len(Jop)):
        LCOH_column_names.append("EC_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("kg_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("CAP_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("OM_Jop" + str(round(Jop[i], 2)))

    for i in range(len(Jop)):
        LCOH_column_names.append("mLCOH_Jop" + str(round(Jop[i], 2)))

    for name in ["mLCOH_min", "m_ECmin", "OptimalJop","m_kgmin","m_CAPmin","m_OMmin"]:
        LCOH_column_names.append(name)

    hour = 0
    break_point_list = [None for item in Vop_copy]
    for price in dfElPrice:
        hour+=1     
#Make EC NAN if terminal voltage is reached - Feb 7, 2022
# if Vop is > Vthreshold make EC NAN
#     if Vop_copy >= V_threshold: #in Mode 2A Vop_copy is an array
#         if break_point == None:
#             break_point = hour 
    #determine when EOL reached with hour variable
#             EC = [np.nan for i in Jop] #must be an array and work for all Jop options - Feb 7, 2022
        condition = Vop_copy >= V_threshold
#check if break point reached for each Jop
        for i_cond in range(len(condition)):
            if condition[i_cond] == True:
                if break_point_list[i_cond] == None:
                    break_point_list[i_cond] = hour
    

#     if condition[1] == True:
#         if break_point_0_1 == None:
#             break_point_0_1 = hour 
#     if condition[2] == True:
#         if break_point_1_7 == None:
#             break_point_1_7 = hour 

        EC = np.where(condition, np.nan, price * (A * Jop * Vop_copy) / 1000) #makes EC nAn if >=threshold
#             EC = np.array(EC)
        # Preq is a numpy array


        #set_trace()

        # if EC is NAN then make the corresponding elements NAN
        # in M_kg2, M_CAPEX and M_OM

        M_kgh2  = np.where(np.isnan(EC), np.nan, M_kgh2)
#         M_CAPEX = np.where(np.isnan(EC), np.nan, M_CAPEX)
        M_OM    = np.where(np.isnan(EC), np.nan, M_OM)

        #set_trace()

        # array
        marginal_LCOH_value = np.where(M_kgh2==0, np.nan, (EC + M_CAPEX + M_OM)/M_kgh2)

        try:
            margLCOH_min = np.nanmin(marginal_LCOH_value) #np.nanmin
            margLCOH_min_index = np.nanargmin(marginal_LCOH_value) # np.nanargmin
        except ValueError:
            margLCOH_min = np.min(marginal_LCOH_value) #np.nanmin
            margLCOH_min_index = np.argmin(marginal_LCOH_value) # np.nanargmin
        #set_trace()

        #marginal LCOH per Jop
        # 0 = energy charge; 1 = kg; 2 = CAPEX; 3 = OM; 4 = marginal LCOH
        #marginal_LCOH_value = ((LCOH_hourly_data[2] + LCOH_hourly_data[3] + LCOH_hourly_data[0])/LCOH_hourly_data[1])
        #LCOH_hourly_data.append(marginal_LCOH_value)

#                 # Compare all columns and pick up the minimum LCOH - no comparison for mode 1A
#         for df_LCOH in df_LCOH_total_list:  

        #minimum LCOH per hour - ignore nan values
        #margLCOH_min = np.nanmin(marginal_LCOH_value)
        #margLCOH_min_index = np.nanargmin(marginal_LCOH_value)
        #LCOH_hourly_data.append(LCOH_hourly_data[4]) #minimum marginal LCOH is the same as the marginal LCOH for Mode 1A; only one Jop

        #set_trace()

        #Energy charge minimum
        EC_min = EC[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[0]) #only one value for Mode 1A

        #Jop that minimizes marginal LCOH  and corresponding Vop
        Jop_min = Jop[margLCOH_min_index]
        if Jop_min == 0: Jop_min = np.nan #boundary condition to avoid zero as optimal Jop
        Vop_copy_min = Vop_copy[margLCOH_min_index]
        #LCOH_hourly_data.append(Jop_) #for one value of 1.7, from while loop

        #kg associated with min LCOH
        M_kgh2_min = M_kgh2[margLCOH_min_index]
        #LCOH_hourly_data.append(LCOH_hourly_data[1]) 

        #CAP associated with min LCOH
        M_CAP_min = M_CAPEX[margLCOH_min_index]

        #OM associated with min LCOH
        M_OM_min = M_OM[margLCOH_min_index]

#         set_trace()

        # calculate degradation amount on the Vop 
        # that minimizes margLCOH
        Degradation_Amount = Vop_copy_min * Degradation_Rate  #increase in voltage

        # all the Vop's (Vop_copy is a copy of Vop) are degraded to 
        # the same amount 
        Vop_copy += Degradation_Amount

        Degradation_List.append(Degradation_Amount) #collect degradation amounts
#         set_trace()

        #add hourly degradation to V_plot for plotting
        #v_plot += Degradation_Amount
        #v_plot = [x + Degradation_Amount for x in v_plot]
        iv_plotting_3.append(iv_plotting_3[-1] + Degradation_Amount)

#         set_trace()

#                 LCOH_column_names = ["EC_Jop" + str(round(Jop[i], 2)), "kg_Jop" + str(round(Jop[i], 2)), 
#                               "CAP_Jop" + str(round(Jop[i], 2)), "OM_Jop" + str(round(Jop[i], 2)),
#                               "mLCOH_Jop" + str(round(Jop[i], 2)), "mLCOH_min", "m_ECmin", 
#                               "OptimalJop","m_kgmin"]
        data_row = np.hstack((EC, M_kgh2, M_CAPEX, M_OM, marginal_LCOH_value, 
                            margLCOH_min, EC_min, Jop_min, M_kgh2_min, M_CAP_min, M_OM_min))
        LCOH_2D_data.append(data_row)
        
#         set_trace()

    break_point_dictionary[str(round(Jop[-1],2))] = break_point_list,Jop
# #################################################################
# ###################################################################
#     set_trace()
    #all 10 years
    df_LCOH = pd.DataFrame(data=LCOH_2D_data,columns=LCOH_column_names)
    CAP_Total = (df_LCOH["m_CAPmin"].sum()) #whole CAPEX sum
#     OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())
#     set_trace()

#split into 10 years for the DCFA
    df_LCOH_total_list = []  # holds all of 10 individual dataframess, 1 for each year
    start = 0
    stop = Life_1year
    for i in range(10):
        df_LCOH_temp = df_LCOH.iloc[start:stop]
        df_LCOH_total_list.append(df_LCOH_temp)  # saves each year in a list so can loop through
        start = stop
        stop = (i + 2) * Life_1year # cycles though each year

    for df in df_LCOH_total_list:
        df.index = range(Life_1year)
#     set_trace()

       #12.28.21 - sum kg and EC for 10 years in 1 year increments

    OptimalEC_List_DCFA = []
    OptimalKG_List_DCFA = []
    OptimalOM_List_DCFA = []
    for df_LCOH in df_LCOH_total_list:
        OptimalEC_List_DCFA.append(np.nansum(df_LCOH["m_ECmin"]))
        OptimalKG_List_DCFA.append(np.nansum(df_LCOH["m_kgmin"]))
        OptimalOM_List_DCFA.append(np.nansum(df_LCOH["m_OMmin"]))

#         OM_Total_1st = (df_LCOH_total_list[9]["m_OMmin"].sum())

#     set_trace()     

    df_DCFA = pd.DataFrame(data={})
    df_DCFA["Year"] = list(range(0, 11))

    df_DCFA["CAPEX"] = [CAP_Total if i == 0 else 0 for i in range(11)]

    df_DCFA["PWF"] = [1 / (1 + DR) ** df_DCFA["Year"][i] for i in range(11)]

    OptimalOM_List_DCFA.insert(0, 0)
    df_DCFA["PV_OM"] = [0 if i == 0 else (OptimalOM_List_DCFA[i] * 10 * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalEC_List_DCFA.insert(0, 0)
    df_DCFA["PV_EC"] = [0 if i == 0 else (OptimalEC_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

    OptimalKG_List_DCFA.insert(0, 0)
    df_DCFA["PV_KG"] = [0 if i == 0 else (OptimalKG_List_DCFA[i] * df_DCFA["PWF"][i]) for i in range(11)]

#         # Calculate LCOH

    PV_Costs = (df_DCFA["CAPEX"].sum() + df_DCFA["PV_OM"].sum() + df_DCFA["PV_EC"].sum())  

    PV_KG = df_DCFA["PV_KG"].sum()
    Lifetime_LCOH_dynamic_Jop0baseline = PV_Costs / PV_KG

#         # Contribution analysis

    CAPEX_Cont = df_DCFA["CAPEX"].sum() / PV_Costs * 100

    OM_Cont = df_DCFA["PV_OM"].sum() / PV_Costs * 100

    EC_Cont = df_DCFA["PV_EC"].sum() / PV_Costs * 100

    df_DCFA["PV_KG"].sum()

    OptimalJop_mean = []
    for year in range(10):
        OptimalJop_mean.append(df_LCOH_total_list[year]["OptimalJop"].mean())
    Average_Jop_10yr = np.nansum(OptimalJop_mean) / len(OptimalJop_mean) 
    Year1_Jop = OptimalJop_mean[0]
    Year10_Jop = OptimalJop_mean[9]

#         # write to csv
    print(Jop[-1], Average_Jop_10yr, Lifetime_LCOH_dynamic_Jop0baseline, CAPEX_per_1kW, CAP_Total, df_DCFA["PV_EC"].sum(), df_DCFA["PV_OM"].sum(), PV_Costs, PV_KG, file=f_file,sep=",") 
    print("UNINST CAPperKW:", CAPEX_per_1kW)
    print("INST CAPEX:", CAP_Total)
    print("PV_EC:", df_DCFA["PV_EC"].sum())
    print("PV_KG:", PV_KG)
    print("PV_OM:", df_DCFA["PV_OM"].sum())
    print("LCOH:", Lifetime_LCOH_dynamic_Jop0baseline)
    
    iv_plotting_dict_3[str(round(Jop[0]))] = iv_plotting_3     #Jop[0] corresponds to range stop value
#     iv_plotting_dict_3[str(Jop_range_stop)] = iv_plotting_3

# iv_plotting_mean_dict_3[mean] = iv_plotting_dict_3
    
    #Jop_ += 0.1 #the step interval for Jop_rated; must be down here 
f_file.close() 
df_csv = pd.read_csv("mode3.csv")
df_csv

Year10_Jop

df_DCFA

print("break point hour:", (break_point-1))
EOL = ((break_point-1)/Life_1year)+1
EOL

break_point_dictionary

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook 
for hour in range(0,Life_hours,8759): 
    plt.plot(i_plot,iv_plotting[hour])

#to analyze voltage degradation
degradation_voltages_csv = {}
degradation_voltages_csv["Jop"] = i_plot
for hour in range(0,Life_hours,8759): 
    degradation_voltages_csv[str(hour)] = iv_plotting[hour]

df_degradation_voltages = pd.DataFrame(data=degradation_voltages_csv)
df_degradation_voltages

df_degradation_voltages.to_csv("degraded_voltages_mode3.csv")